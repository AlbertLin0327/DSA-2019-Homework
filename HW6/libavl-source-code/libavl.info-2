This is libavl.info, produced by makeinfo version 4.7 from libavl.texi.



File: libavl.info,  Node: Recursive Insertion,  Prev: AVL Insertion Example,  Up: Inserting into an AVL Tree

5.4.7 Aside: Recursive Insertion
--------------------------------

In previous sections we first looked at recursive approaches because
they were simpler and more elegant than iterative solutions.  As it
happens, the reverse is true for insertion into an AVL tree.  But just
for completeness, we will now design a recursive implementation of
avl_probe().

   Our first task in such a design is to figure out what arguments and
return value the recursive core of the insertion function will have.
We'll begin by considering AVL insertion in the abstract.  Our existing
function avl_probe() works by first moving down the tree, from the root
to a leaf, then back up the tree, from leaf to root, as necessary to
adjust balance factors or rebalance.  In the existing iterative
version, down and up movement are implemented by pushing nodes onto and
popping them off from a stack.  In a recursive version, moving down the
tree becomes a recursive call, and moving up the tree becomes a function
return.

   While descending the tree, the important pieces of information are
the tree itself (to allow for comparisons to be made), the current
node, and the data item we're inserting.  The latter two items need to
be modifiable by the function, the former because the tree rooted at the
node may need to be rearranged during a rebalance, and the latter
because of avl_probe()'s return value.

   While ascending the tree, we'll still have access to all of this
information, but, to allow for adjustment of balance factors and
rebalancing, we also need to know whether the subtree visited in a
nested call became taller.  We can use the function's return value for
this.

   Finally, we know to stop moving down and start moving up when we
find a null pointer in the tree, which is the place for the new node to
be inserted.  This suggests itself naturally as the test used to stop
the recursion.

   Here is an outline of a recursive insertion function directly
corresponding to these considerations:

160. <Recursive insertion into AVL tree 160> =
static int
probe (struct avl_table *tree, struct avl_node **p, void ***data)
{
  struct avl_node *y; /* The current node; shorthand for *p. */

  assert (tree != NULL && p != NULL && data != NULL);

  y = *p;
  if (y == NULL)
    {
      <*Note Found insertion point in recursive AVL insertion: 161.>
    }
  else /* y != NULL */
    {
      <*Note Move down then up in recursive AVL insertion: 162.>
    }
}
   See also *Note 163::.

   Parameter p is declared as a double pointer (struct avl_node **) and
data as a triple pointer (void ***).  In both cases, this is because C
passes arguments by value, so that a function modifying one of its
arguments produces no change in the value seen in the caller.  As a
result, to allow a function to modify a scalar, a pointer to it must be
passed as an argument; to modify a pointer, a double pointer must be
passed; to modify a double pointer, a triple pointer must be passed.
This can result in difficult-to-understand code, so it is often
advisable to copy the dereferenced argument into a local variable for
read-only use, as *p is copied into y here.

   When the insertion point is found, a new node is created and a
pointer to it stored into *p.  Because the insertion causes the subtree
to increase in height (from 0 to 1), a value of 1 is then returned:

161. <Found insertion point in recursive AVL insertion 161> =
y = *p = tree->avl_alloc->libavl_malloc (tree->avl_alloc, sizeof *y);
if (y == NULL)
  {
    *data = NULL;
    return 0;
  }

y->avl_data = **data;
*data = &y->avl_data;
y->avl_link[0] = y->avl_link[1] = NULL;
y->avl_balance = 0;

tree->avl_count++;
tree->avl_generation++;

return 1;
   This code is included in *Note 160::.

   When we're not at the insertion point, we move down, then back up.
Whether to move down to the left or the right depends on the value of
the item to insert relative to the value in the current node y.  Moving
down is the domain of the recursive call to probe().  If the recursive
call doesn't increase the height of a subtree of y, then there's
nothing further to do, so we return immediately.  Otherwise, on the way
back up, it is necessary to at least adjust y's balance factor, and
possibly to rebalance as well.  If only adjustment of the balance
factor is necessary, it is done and the return value is based on
whether this subtree has changed height in the process.  Rebalancing is
accomplished using the same code used in iterative insertion.  A
rebalanced subtree has the same height as before insertion, so the value
returned is 0.  The details are in the code itself:

162. <Move down then up in recursive AVL insertion 162> =
struct avl_node *w; /* New root of this subtree; replaces *p. */
int cmp;

cmp = tree->avl_compare (**data, y->avl_data, tree->avl_param);
if (cmp < 0)
  {
    if (probe (tree, &y->avl_link[0], data) == 0)
      return 0;

    if (y->avl_balance == +1)
      {
        y->avl_balance = 0;
        return 0;
      }
    else if (y->avl_balance == 0)
      {
        y->avl_balance = -1;
        return 1;
      }
    else
      {
        <*Note Rebalance AVL tree after insertion in left subtree: 152.>
      }
  }
else if (cmp > 0)
  {
    struct avl_node *r; /* Right child of y, for rebalancing. */

    if (probe (tree, &y->avl_link[1], data) == 0)
      return 0;

    if (y->avl_balance == -1)
      {
        y->avl_balance = 0;
        return 0;
      }
    else if (y->avl_balance == 0)
      {
        y->avl_balance = +1;
        return 1;
      }
    else
      {
        <*Note Rebalance AVL tree after insertion in right subtree: 157.>
      }
  }
else /* cmp == 0 */
  {
    *data = &y->avl_data;
    return 0;
  }

*p = w;
return 0;
   This code is included in *Note 160::.

   Finally, we need a wrapper function to start the recursion off
correctly and deal with passing back the results:

163. <Recursive insertion into AVL tree 160> +=
/* Inserts item into tree and returns a pointer to item's address.
   If a duplicate item is found in the tree,
   returns a pointer to the duplicate without inserting item.
   Returns NULL in case of memory allocation failure. */
void **
avl_probe (struct avl_table *tree, void *item)
{
  void **ret = &item;

  probe (tree, &tree->avl_root, &ret);

  return ret;
}


File: libavl.info,  Node: Deleting from an AVL Tree,  Next: Traversal of an AVL Tree,  Prev: Inserting into an AVL Tree,  Up: AVL Trees

5.5 Deletion
============

Deletion in an AVL tree is remarkably similar to insertion.  The steps
that we go through are analogous:

  1. *Search* for the item to delete.

  2. *Delete* the item.

  3. *Update* balance factors.

  4. *Rebalance* the tree, if necessary.

  5. *Finish up* and return.

   The main difference is that, after a deletion, we may have to
rebalance at more than one level of a tree, starting from the bottom
up.  This is a bit painful, because it means that we have to keep track
of all the nodes that we visit as we search for the node to delete, so
that we can then move back up the tree.  The actual updating of balance
factors and rebalancing steps are similar to those used for insertion.

   The following sections cover deletion from an AVL tree in detail.
Before we get started, here's an outline of the function.

164. <AVL item deletion function 164> =
void *
avl_delete (struct avl_table *tree, const void *item)
{
  /* Stack of nodes. */
  struct avl_node *pa[AVL_MAX_HEIGHT]; /* Nodes. */
  unsigned char da[AVL_MAX_HEIGHT];    /* avl_link[] indexes. */
  int k;                               /* Stack pointer. */

  struct avl_node *p;   /* Traverses tree to find node to delete. */
  int cmp;              /* Result of comparison between item and p. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search AVL tree for item to delete: 165.>
  <*Note Step 2: Delete item from AVL tree: 166.>
  <*Note Steps 3-4: Update balance factors and rebalance after AVL deletion: 171.>
  <*Note Step 5: Finish up and return after AVL deletion: 176.>
}
   This code is included in *Note 145::.

See also:  *Note Knuth 1998b::, pages 473-474; *Note Pfaff 1998::.

* Menu:

* Deleting an AVL Node Step 1 - Search::
* Deleting an AVL Node Step 2 - Delete::
* Deleting an AVL Node Step 3 - Update::
* Deleting an AVL Node Step 4 - Rebalance::
* Deleting an AVL Node Step 5 - Finish Up::
* AVL Deletion Symmetric Case::


File: libavl.info,  Node: Deleting an AVL Node Step 1 - Search,  Next: Deleting an AVL Node Step 2 - Delete,  Prev: Deleting from an AVL Tree,  Up: Deleting from an AVL Tree

5.5.1 Step 1: Search
--------------------

The only difference between this search and an ordinary search in a BST
is that we have to keep track of the nodes above the one we're
deleting.  We do this by pushing them onto the stack defined above.
Each iteration through the loop compares item to p's data, pushes the
node onto the stack, moves down in the proper direction.  The first
trip through the loop is something of an exception: we hard-code the
comparison result to -1 so that the pseudo-root node is always the
topmost node on the stack.  When we find a match, we set item to the
actual data item found, so that we can return it later.

165. <Step 1: Search AVL tree for item to delete 165> =
k = 0;
p = (struct avl_node *) &tree->avl_root;
for (cmp = -1; cmp != 0;
     cmp = tree->avl_compare (item, p->avl_data, tree->avl_param))
  {
    int dir = cmp > 0;

    pa[k] = p;
    da[k++] = dir;

    p = p->avl_link[dir];
    if (p == NULL)
      return NULL;
  }
item = p->avl_data;
   This code is included in *Note 164:: and *Note 220::.


File: libavl.info,  Node: Deleting an AVL Node Step 2 - Delete,  Next: Deleting an AVL Node Step 3 - Update,  Prev: Deleting an AVL Node Step 1 - Search,  Up: Deleting from an AVL Tree

5.5.2 Step 2: Delete
--------------------

At this point, we've identified p as the node to delete.  The node on
the top of the stack, da[k - 1], is p's parent node.  There are the same
three cases we saw in deletion from an ordinary BST (*note Deleting
from a BST::), with the addition of code to copy balance factors and
update the stack.

   The code for selecting cases is the same as for BSTs:

166. <Step 2: Delete item from AVL tree 166> =
if (p->avl_link[1] == NULL)
  { <*Note Case 1 in AVL deletion: 168.> }
else
  {
    struct avl_node *r = p->avl_link[1];
    if (r->avl_link[0] == NULL)
      {
        <*Note Case 2 in AVL deletion: 169.>
      }
    else
      {
        <*Note Case 3 in AVL deletion: 170.>
      }
  }
   See also *Note 167::.
This code is included in *Note 164::.

   Regardless of the case, we are in the same situation after the
deletion: node p has been removed from the tree and the stack contains
k nodes at which rebalancing may be necessary.  Later code may change p
to point elsewhere, so we free the node immediately.  A pointer to the
item data has already been saved in item (*note avldelsaveitem::):

167. <Step 2: Delete item from AVL tree 166> +=
tree->avl_alloc->libavl_free (tree->avl_alloc, p);

Case 1: p has no right child
............................

If p has no right child, then we can replace it with its left child,
the same as for BSTs (*note bstdelcase1::).

168. <Case 1 in AVL deletion 168> =
pa[k - 1]->avl_link[da[k - 1]] = p->avl_link[0];
   This code is included in *Note 166::.

Case 2: p's right child has no left child
.........................................

If p has a right child r, which in turn has no left child, then we
replace p by r, attaching p's left child to r, as we would in an
unbalanced BST (*note bstdelcase2::).  In addition, r acquires p's
balance factor, and r must be added to the stack of nodes above the
deleted node.

169. <Case 2 in AVL deletion 169> =
r->avl_link[0] = p->avl_link[0];
r->avl_balance = p->avl_balance;
pa[k - 1]->avl_link[da[k - 1]] = r;
da[k] = 1;
pa[k++] = r;
   This code is included in *Note 166::.

Case 3: p's right child has a left child
........................................

If p's right child has a left child, then this is the third and most
complicated case.  On the other hand, as a modification from the third
case in an ordinary BST deletion (*note bstdelcase3::), it is rather
simple.  We're deleting the inorder successor of p, so we push the
nodes above it onto the stack.  The only trickery is that we do not
know in advance the node that will replace p, so we reserve a spot on
the stack for it (da[j]) and fill it in later:

170. <Case 3 in AVL deletion 170> =
struct avl_node *s;
int j = k++;

for (;;)
  {
    da[k] = 0;
    pa[k++] = r;
    s = r->avl_link[0];
    if (s->avl_link[0] == NULL)
      break;

    r = s;
  }

s->avl_link[0] = p->avl_link[0];
r->avl_link[0] = s->avl_link[1];
s->avl_link[1] = p->avl_link[1];
s->avl_balance = p->avl_balance;

pa[j - 1]->avl_link[da[j - 1]] = s;
da[j] = 1;
pa[j] = s;
   This code is included in *Note 166::.

Exercises:

1. Write an alternate version of <*Note Case 3 in AVL deletion: 170.>
that moves data instead of pointers, as in Exercise 4.8-2.  [*Note
answer: 5-5-2#1..]

2. Why is it important that the item data was saved earlier?  (Why
couldn't we save it just before freeing the node?)  [*Note answer:
5-5-2#2..]


File: libavl.info,  Node: Deleting an AVL Node Step 3 - Update,  Next: Deleting an AVL Node Step 4 - Rebalance,  Prev: Deleting an AVL Node Step 2 - Delete,  Up: Deleting from an AVL Tree

5.5.3 Step 3: Update Balance Factors
------------------------------------

When we updated balance factors in insertion, we were lucky enough to
know in advance which ones we'd need to update.  Moreover, we never
needed to rebalance at more than one level in the tree for any one
insertion.  These two factors conspired in our favor to let us do all
the updating of balance factors at once from the top down.

   Everything is not quite so simple in AVL deletion.  We don't have any
easy way to figure out during the search process which balance factors
will need to be updated, and for that matter we may need to perform
rebalancing at multiple levels.  Our strategy must change.

   This new approach is not fundamentally different from the previous
one.  We work from the bottom up instead of from the top down.  We
potentially look at each of the nodes along the direct path from the
deleted node to the tree's root, starting at pa[k - 1], the parent of
the deleted node.  For each of these nodes, we adjust its balance
factor and possibly perform rebalancing.  After that, if we're lucky,
this was enough to restore the tree's balancing rule, and we are
finished with updating balance factors and rebalancing.  Otherwise, we
look at the next node, repeating the process.

   Here is the loop itself with the details abstracted out:

171. <Steps 3-4: Update balance factors and rebalance after AVL deletion 171> =
assert (k > 0);
while (-k > 0)
  {
    struct avl_node *y = pa[k];

    if (da[k] == 0)
      {
        <*Note Update y's balance factor after left-side AVL deletion: 172.>
      }
    else
      {
        <*Note Update y's balance factor after right-side AVL deletion: 177.>
      }
  }
   This code is included in *Note 164::.

   The reason this works is the loop invariants.  That is, because each
time we look at a node in order to update its balance factor, the
situation is the same.  In particular, if we're looking at a node
pa[k], then we know that it's because the height of its subtree on side
da[k] decreased, so that the balance factor of node pa[k] needs to be
updated.  The rebalancing operations we choose reflect this invariant:
there are sometimes multiple valid ways to rebalance at a given node
and propagate the results up the tree, but only one way to do this
while maintaining the invariant.  (This is especially true in red-black
trees, for which we will develop code for two possible invariants under
insertion and deletion.)

   Updating the balance factor of a node after deletion from its left
side and right side are symmetric, so we'll discuss only the left-side
case here and construct the code for the right-side case later.
Suppose we have a node y whose left subtree has decreased in height.
In general, this increases its balance factor, because the balance
factor of a node is the height of its right subtree minus the height of
its left subtree.  More specifically, there are three cases, treated
individually below.

Case 1: y has - balance factor
..............................

If y started with a - balance factor, then its left subtree was taller
than its right subtree.  Its left subtree has decreased in height, so
the two subtrees must now be the same height and we set y's balance
factor to 0.  This is between -1 and +1, so there is no need to
rebalance at y.  However, binary tree y has itself decreased in height,
so that means that we must rebalance the AVL tree above y as well, so
we continue to the next iteration of the loop.

   The diagram below may help in visualization.  On the left is shown
the original configuration of a subtree, where subtree a has height h
and subtree b has height h - 1.  The height of a nonempty binary tree
is one plus the larger of its subtrees' heights, so tree y has height h
+ 1.  The diagram on the right shows the situation after a node has
been deleted from a, reducing that subtree's height.  The new height of
tree y is (h - 1) + 1 == h.

 [image src="avldelre1.png" text="                            |             |
                            y             y
                           <->           <0>
                          /   \\    =>  _'   \\
                         a      b     a*      b
                         h     h-1    h-1    h-1

" ]

Case 2: y has 0 balance factor
..............................

If y started with a 0 balance factor, and its left subtree decreased in
height, then the result is that its right subtree is now taller than its
left subtree, so the new balance factor is +.  However, the overall
height of binary tree y has not changed, so no balance factors above y
need to be changed, and we are done, hence we break to exit the loop.

   Here's the corresponding diagram, similar to the one for the previous
case.  The height of tree y on both sides of the diagram is h + 1,
since y's taller subtree in both cases has height h.

 [image src="avldelre2.png" text="                              |           |
                              y           y
                             <0>         <+>
                            /   \\  =>  _'   \\
                           a     b    a*     b
                           h     h    h-1    h

" ]

Case 3: y has + balance factor
..............................

Otherwise, y started with a + balance factor, so the decrease in height
of its left subtree, which was already shorter than its right subtree,
causes a violation of the AVL constraint with a +2 balance factor.  We
need to rebalance.  After rebalancing, we may or may not have to
rebalance further up the tree.

   Here's a diagram of what happens to forcing rebalancing:

 [image src="avldelre3.png" text="                              |            |
                              y            y
                             <+>         <++>
                           _'   \\  =>  _'    \\
                           a     b    a*      b
                          h-1    h    h-2     h

" ]

Implementation
..............

The implementation is straightforward:

172. <Update y's balance factor after left-side AVL deletion 172> =
y->avl_balance++;
if (y->avl_balance == +1)
  break;
else if (y->avl_balance == +2)
  {
    <*Note Step 4: Rebalance after AVL deletion: 173.>
  }
   This code is included in *Note 171::.


File: libavl.info,  Node: Deleting an AVL Node Step 4 - Rebalance,  Next: Deleting an AVL Node Step 5 - Finish Up,  Prev: Deleting an AVL Node Step 3 - Update,  Up: Deleting from an AVL Tree

5.5.4 Step 4: Rebalance
-----------------------

Now we have to write code to rebalance when it becomes necessary.
We'll use rotations to do this, as before.  Again, we'll distinguish
the cases on the basis of x's balance factor, where x is y's right
child:

173. <Step 4: Rebalance after AVL deletion 173> =
struct avl_node *x = y->avl_link[1];
if (x->avl_balance == -1)
  {
    <*Note Left-side rebalancing case 1 in AVL deletion: 174.>
  }
else
  {
    <*Note Left-side rebalancing case 2 in AVL deletion: 175.>
  }
   This code is included in *Note 172::.

Case 1: x has - balance factor
..............................

If x has a - balance factor, we handle rebalancing in a manner
analogous to case 2 for insertion.  In fact, we reuse the code.  We
rotate right at x, then left at y.  w is the left child of x.  The two
rotations look like this:

 [image src="avldel1.png" text="                   |                 |
                   y                 y               |
                 <++>              <++>              w
                /    `._          /    `_           <0>
               a         x       a       w    =>   /   \\
                        <->   =>        / \\       y     x
                       /   \\           b   x      ^     ^
                      w     d              ^     a b   c d
                      ^                   c d
                     b c

" ]

174. <Left-side rebalancing case 1 in AVL deletion 174> =
struct avl_node *w;
<*Note Rotate right at x then left at y in AVL tree: 159.>
pa[k - 1]->avl_link[da[k - 1]] = w;
This code is included in *Note 173::.

Case 2: x has + or 0 balance factor
...................................

When x's balance factor is +, the needed treatment is analogous to Case
1 for insertion.  We simply rotate left at y and update the pointer to
the subtree, then update balance factors.  The deletion and rebalancing
then look like this:

 [image src="avldel2.png" text="                 |                |                    |
                 y                y                    x
                <+>             <++>                  <0>
               /   `_          /    `_            _.-'   \\
              a       x    => a*       x    =>    y       c
                     <+>              <+>        <0>
                    /   \\            /   \\      /   \\
                   b     c          b     c    a*    b

" ]

When x's balance factor is 0, we perform the same rotation, but the
height of the overall subtree does not change, so we're done and can
exit the loop with break.  Here's what the deletion and rebalancing
look like for this subcase:

 [image src="avldel3.png" text="                 |                |                    |
                 y                y                    x
                <+>             <++>                  <->
               /   `_          /    `_            _.-'   \\
              a       x    => a*       x    =>    y       c
                     <0>              <0>        <+>
                    /   \\            /   \\      /   \\
                   b     c          b     c    a*    b

" ]

175. <Left-side rebalancing case 2 in AVL deletion 175> =
y->avl_link[1] = x->avl_link[0];
x->avl_link[0] = y;
pa[k - 1]->avl_link[da[k - 1]] = x;
if (x->avl_balance == 0)
  {
    x->avl_balance = -1;
    y->avl_balance = +1;
    break;
  }
else
  x->avl_balance = y->avl_balance = 0;
This code is included in *Note 173::.

Exercises:

1. In <*Note Step 4: Rebalance after AVL deletion: 173.>, we refer to
fields in x, the right child of y, without checking that y has a
non-null right child.  Why can we assume that node x is non-null?
[*Note answer: 5-5-4#1..]

2. Describe the shape of a tree that might require rebalancing at every
level above a particular node.  Give an example.  [*Note answer:
5-5-4#2..]


File: libavl.info,  Node: Deleting an AVL Node Step 5 - Finish Up,  Next: AVL Deletion Symmetric Case,  Prev: Deleting an AVL Node Step 4 - Rebalance,  Up: Deleting from an AVL Tree

5.5.5 Step 5: Finish Up
-----------------------

176. <Step 5: Finish up and return after AVL deletion 176> =
tree->avl_count-;
tree->avl_generation++;
return (void *) item;
This code is included in *Note 164::.


File: libavl.info,  Node: AVL Deletion Symmetric Case,  Prev: Deleting an AVL Node Step 5 - Finish Up,  Up: Deleting from an AVL Tree

5.5.6 Symmetric Case
--------------------

Here's the code for the symmetric case, where the deleted node was in
the right subtree of its parent.

177. <Update y's balance factor after right-side AVL deletion 177> =
y->avl_balance-;
if (y->avl_balance == -1)
  break;
else if (y->avl_balance == -2)
  {
    struct avl_node *x = y->avl_link[0];
    if (x->avl_balance == +1)
      {
        struct avl_node *w;
        <*Note Rotate left at x then right at y in AVL tree: 156.>
        pa[k - 1]->avl_link[da[k - 1]] = w;
      }
    else
      {
        y->avl_link[0] = x->avl_link[1];
        x->avl_link[1] = y;
        pa[k - 1]->avl_link[da[k - 1]] = x;
        if (x->avl_balance == 0)
          {
            x->avl_balance = +1;
            y->avl_balance = -1;
            break;
          }
        else
          x->avl_balance = y->avl_balance = 0;
      }
  }
   This code is included in *Note 171::.


File: libavl.info,  Node: Traversal of an AVL Tree,  Next: Copying an AVL Tree,  Prev: Deleting from an AVL Tree,  Up: AVL Trees

5.6 Traversal
=============

Traversal is largely unchanged from BSTs.  However, we can be confident
that the tree won't easily exceed the maximum stack height, because of
the AVL balance condition, so we can omit checking for stack overflow.

178. <AVL traversal functions 178> =
<*Note BST traverser refresher; bst => avl: 62.>
<*Note BST traverser null initializer; bst => avl: 64.>
<*Note AVL traverser least-item initializer: 180.>
<*Note AVL traverser greatest-item initializer: 181.>
<*Note AVL traverser search initializer: 182.>
<*Note AVL traverser insertion initializer: 179.>
<*Note BST traverser copy initializer; bst => avl: 69.>
<*Note AVL traverser advance function: 183.>
<*Note AVL traverser back up function: 184.>
<*Note BST traverser current item function; bst => avl: 74.>
<*Note BST traverser replacement function; bst => avl: 75.>
   This code is included in *Note 145:: and *Note 196::.

   We do need to make a new implementation of the insertion traverser
initializer.  Because insertion into an AVL tree is so complicated, we
just write this as a wrapper to avl_probe().  There probably wouldn't
be much of a speed improvement by inlining the code anyhow:

179. <AVL traverser insertion initializer 179> =
void *
avl_t_insert (struct avl_traverser *trav, struct avl_table *tree, void *item)
{
  void **p;

  assert (trav != NULL && tree != NULL && item != NULL);

  p = avl_probe (tree, item);
  if (p != NULL)
    {
      trav->avl_table = tree;
      trav->avl_node =
        ((struct avl_node *)
         ((char *) p - offsetof (struct avl_node, avl_data)));
      trav->avl_generation = tree->avl_generation - 1;
      return *p;
    }
  else
    {
      avl_t_init (trav, tree);
      return NULL;
    }
}
   This code is included in *Note 178::.

   We will present the rest of the modified functions without further
comment.

180. <AVL traverser least-item initializer 180> =
void *
avl_t_first (struct avl_traverser *trav, struct avl_table *tree)
{
  struct avl_node *x;

  assert (tree != NULL && trav != NULL);

  trav->avl_table = tree;
  trav->avl_height = 0;
  trav->avl_generation = tree->avl_generation;

  x = tree->avl_root;
  if (x != NULL)
    while (x->avl_link[0] != NULL)
      {
        assert (trav->avl_height < AVL_MAX_HEIGHT);
        trav->avl_stack[trav->avl_height++] = x;
        x = x->avl_link[0];
      }
  trav->avl_node = x;

  return x != NULL ? x->avl_data : NULL;
}
   This code is included in *Note 178::.

181. <AVL traverser greatest-item initializer 181> =
void *
avl_t_last (struct avl_traverser *trav, struct avl_table *tree)
{
  struct avl_node *x;

  assert (tree != NULL && trav != NULL);

  trav->avl_table = tree;
  trav->avl_height = 0;
  trav->avl_generation = tree->avl_generation;

  x = tree->avl_root;
  if (x != NULL)
    while (x->avl_link[1] != NULL)
      {
        assert (trav->avl_height < AVL_MAX_HEIGHT);
        trav->avl_stack[trav->avl_height++] = x;
        x = x->avl_link[1];
      }
  trav->avl_node = x;

  return x != NULL ? x->avl_data : NULL;
}
   This code is included in *Note 178::.

182. <AVL traverser search initializer 182> =
void *
avl_t_find (struct avl_traverser *trav, struct avl_table *tree, void *item)
{
  struct avl_node *p, *q;

  assert (trav != NULL && tree != NULL && item != NULL);
  trav->avl_table = tree;
  trav->avl_height = 0;
  trav->avl_generation = tree->avl_generation;
  for (p = tree->avl_root; p != NULL; p = q)
    {
      int cmp = tree->avl_compare (item, p->avl_data, tree->avl_param);

      if (cmp < 0)
        q = p->avl_link[0];
      else if (cmp > 0)
        q = p->avl_link[1];
      else /* cmp == 0 */
        {
          trav->avl_node = p;
          return p->avl_data;
        }

      assert (trav->avl_height < AVL_MAX_HEIGHT);
      trav->avl_stack[trav->avl_height++] = p;
    }

  trav->avl_height = 0;
  trav->avl_node = NULL;
  return NULL;
}
   This code is included in *Note 178::.

183. <AVL traverser advance function 183> =
void *
avl_t_next (struct avl_traverser *trav)
{
  struct avl_node *x;

  assert (trav != NULL);

  if (trav->avl_generation != trav->avl_table->avl_generation)
    trav_refresh (trav);

  x = trav->avl_node;
  if (x == NULL)
    {
      return avl_t_first (trav, trav->avl_table);
    }
  else if (x->avl_link[1] != NULL)
    {
      assert (trav->avl_height < AVL_MAX_HEIGHT);
      trav->avl_stack[trav->avl_height++] = x;
      x = x->avl_link[1];

      while (x->avl_link[0] != NULL)
        {
          assert (trav->avl_height < AVL_MAX_HEIGHT);
          trav->avl_stack[trav->avl_height++] = x;
          x = x->avl_link[0];
        }
    }
  else
    {
      struct avl_node *y;

      do
        {
          if (trav->avl_height == 0)
            {
              trav->avl_node = NULL;
              return NULL;
            }

          y = x;
          x = trav->avl_stack[-trav->avl_height];
        }
      while (y == x->avl_link[1]);
    }
  trav->avl_node = x;

  return x->avl_data;
}
   This code is included in *Note 178::.

184. <AVL traverser back up function 184> =
void *
avl_t_prev (struct avl_traverser *trav)
{
  struct avl_node *x;

  assert (trav != NULL);

  if (trav->avl_generation != trav->avl_table->avl_generation)
    trav_refresh (trav);

  x = trav->avl_node;
  if (x == NULL)
    {
      return avl_t_last (trav, trav->avl_table);
    }
  else if (x->avl_link[0] != NULL)
    {
      assert (trav->avl_height < AVL_MAX_HEIGHT);
      trav->avl_stack[trav->avl_height++] = x;
      x = x->avl_link[0];

      while (x->avl_link[1] != NULL)
        {
          assert (trav->avl_height < AVL_MAX_HEIGHT);
          trav->avl_stack[trav->avl_height++] = x;
          x = x->avl_link[1];
        }
    }
  else
    {
      struct avl_node *y;

      do
        {
          if (trav->avl_height == 0)
            {
              trav->avl_node = NULL;
              return NULL;
            }

          y = x;
          x = trav->avl_stack[-trav->avl_height];
        }
      while (y == x->avl_link[0]);
    }
  trav->avl_node = x;

  return x->avl_data;
}
   This code is included in *Note 178::.

Exercises:

1. Explain the meaning of this ugly expression, used in avl_t_insert():

    (struct avl_node *) ((char *) p - offsetof (struct avl_node, avl_data))

   [*Note answer: 5-6#1..]


File: libavl.info,  Node: Copying an AVL Tree,  Next: Testing AVL Trees,  Prev: Traversal of an AVL Tree,  Up: AVL Trees

5.7 Copying
===========

Copying an AVL tree is similar to copying a BST.  The only important
difference is that we have to copy the AVL balance factor between nodes
as well as node data.  We don't check our stack height here, either.

185. <AVL copy function 185> =
<*Note BST copy error helper function; bst => avl: 82.>

struct avl_table *
avl_copy (const struct avl_table *org, avl_copy_func *copy,
          avl_item_func *destroy, struct libavl_allocator *allocator)
{
  struct avl_node *stack[2 * (AVL_MAX_HEIGHT + 1)];
  int height = 0;

  struct avl_table *new;
  const struct avl_node *x;
  struct avl_node *y;

  assert (org != NULL);
  new = avl_create (org->avl_compare, org->avl_param,
                    allocator != NULL ? allocator : org->avl_alloc);
  if (new == NULL)
    return NULL;
  new->avl_count = org->avl_count;
  if (new->avl_count == 0)
    return new;

  x = (const struct avl_node *) &org->avl_root;
  y = (struct avl_node *) &new->avl_root;
  for (;;)
    {
      while (x->avl_link[0] != NULL)
        {
          assert (height < 2 * (AVL_MAX_HEIGHT + 1));

          y->avl_link[0] =
            new->avl_alloc->libavl_malloc (new->avl_alloc,
                                           sizeof *y->avl_link[0]);
          if (y->avl_link[0] == NULL)
            {
              if (y != (struct avl_node *) &new->avl_root)
                {
                  y->avl_data = NULL;
                  y->avl_link[1] = NULL;
                }

              copy_error_recovery (stack, height, new, destroy);
              return NULL;
            }

          stack[height++] = (struct avl_node *) x;
          stack[height++] = y;
          x = x->avl_link[0];
          y = y->avl_link[0];
        }
      y->avl_link[0] = NULL;

      for (;;)
        {
          y->avl_balance = x->avl_balance;
          if (copy == NULL)
            y->avl_data = x->avl_data;
          else
            {
              y->avl_data = copy (x->avl_data, org->avl_param);
              if (y->avl_data == NULL)
                {
                  y->avl_link[1] = NULL;
                  copy_error_recovery (stack, height, new, destroy);
                  return NULL;
                }
            }

          if (x->avl_link[1] != NULL)
            {
              y->avl_link[1] =
                new->avl_alloc->libavl_malloc (new->avl_alloc,
                                               sizeof *y->avl_link[1]);
              if (y->avl_link[1] == NULL)
                {
                  copy_error_recovery (stack, height, new, destroy);
                  return NULL;
                }

              x = x->avl_link[1];
              y = y->avl_link[1];
              break;
            }
          else
            y->avl_link[1] = NULL;

          if (height <= 2)
            return new;

          y = stack[-height];
          x = stack[-height];
        }
    }
}
   This code is included in *Note 145:: and *Note 196::.


File: libavl.info,  Node: Testing AVL Trees,  Prev: Copying an AVL Tree,  Up: AVL Trees

5.8 Testing
===========

Our job isn't done until we can demonstrate that our code works.  We'll
do this with a test program built using the framework from the previous
chapter (*note Testing BST Functions::).  All we have to do is produce
functions for AVL trees that correspond to each of those in <*Note
bst-test.c: 98.>.  This just involves making small changes to the
functions used there.  They are presented below without additional
comment.

186. <avl-test.c 186> =
<*Note License: 1.>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "avl.h"
#include "test.h"

<*Note BST print function; bst => avl: 119.>
<*Note BST traverser check function; bst => avl: 104.>
<*Note Compare two AVL trees for structure and content: 187.>
<*Note Recursively verify AVL tree structure: 188.>
<*Note AVL tree verify function: 190.>
<*Note BST test function; bst => avl: 100.>
<*Note BST overflow test function; bst => avl: 122.>

187. <Compare two AVL trees for structure and content 187> =
static int
compare_trees (struct avl_node *a, struct avl_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      assert (a == NULL && b == NULL);
      return 1;
    }

  if (*(int *) a->avl_data != *(int *) b->avl_data
      || ((a->avl_link[0] != NULL) != (b->avl_link[0] != NULL))
      || ((a->avl_link[1] != NULL) != (b->avl_link[1] != NULL))
      || a->avl_balance != b->avl_balance)
    {
      printf (" Copied nodes differ: a=%d (bal=%d) b=%d (bal=%d) a:",
              *(int *) a->avl_data, a->avl_balance,
              *(int *) b->avl_data, b->avl_balance);

      if (a->avl_link[0] != NULL)
        printf ("l");
      if (a->avl_link[1] != NULL)
        printf ("r");

      printf (" b:");
      if (b->avl_link[0] != NULL)
        printf ("l");
      if (b->avl_link[1] != NULL)
        printf ("r");

      printf ("\n");
      return 0;
    }

  okay = 1;
  if (a->avl_link[0] != NULL)
    okay &= compare_trees (a->avl_link[0], b->avl_link[0]);
  if (a->avl_link[1] != NULL)
    okay &= compare_trees (a->avl_link[1], b->avl_link[1]);
  return okay;
}
   This code is included in *Note 186::.

188. <Recursively verify AVL tree structure 188> =
/* Examines the binary tree rooted at node.
   Zeroes *okay if an error occurs.
   Otherwise, does not modify *okay.
   Sets *count to the number of nodes in that tree,
   including node itself if node != NULL.
   Sets *height to the tree's height.
   All the nodes in the tree are verified to be at least min
   but no greater than max. */
static void
recurse_verify_tree (struct avl_node *node, int *okay, size_t *count,
                     int min, int max, int *height)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */
  int subheight[2];     /* Heights of subtrees. */

  if (node == NULL)
    {
      *count = 0;
      *height = 0;
      return;
    }
  d = *(int *) node->avl_data;

  <*Note Verify binary search tree ordering: 114.>

  recurse_verify_tree (node->avl_link[0], okay, &subcount[0],
                       min, d -  1, &subheight[0]);
  recurse_verify_tree (node->avl_link[1], okay, &subcount[1],
                       d + 1, max, &subheight[1]);
  *count = 1 + subcount[0] + subcount[1];
  *height = 1 + (subheight[0] > subheight[1] ? subheight[0] : subheight[1]);

  <*Note Verify AVL node balance factor: 189.>
}
   This code is included in *Note 186::.

189. <Verify AVL node balance factor 189> =
if (subheight[1] - subheight[0] != node->avl_balance)
  {
    printf (" Balance factor of node %d is %d, but should be %d.\n",
            d, node->avl_balance, subheight[1] - subheight[0]);
    *okay = 0;
  }
else if (node->avl_balance < -1 || node->avl_balance > +1)
  {
    printf (" Balance factor of node %d is %d.\n", d, node->avl_balance);
    *okay = 0;
  }
   This code is included in *Note 188::, *Note 332::, *Note 451::, and
*Note 550::.

190. <AVL tree verify function 190> =
static int
verify_tree (struct avl_table *tree, int array[], size_t n)
{
  int okay = 1;

  <*Note Check tree->bst_count is correct; bst => avl: 110.>

  if (okay)
    {
      <*Note Check AVL tree structure: 191.>
    }

  if (okay)
    {
      <*Note Check that the tree contains all the elements it should; bst => avl: 115.>
    }

  if (okay)
    {
      <*Note Check that forward traversal works; bst => avl: 116.>
    }

  if (okay)
    {
      <*Note Check that backward traversal works; bst => avl: 117.>
    }

  if (okay)
    {
      <*Note Check that traversal from the null element works; bst => avl: 118.>
    }

  return okay;
}
   This code is included in *Note 186::, *Note 330::, *Note 449::, and
*Note 548::.

191. <Check AVL tree structure 191> =
/* Recursively verify tree structure. */
size_t count;
int height;

recurse_verify_tree (tree->avl_root, &okay, &count,
                     0, INT_MAX, &height);
<*Note Check counted nodes: 112.>
   This code is included in *Note 190::.


File: libavl.info,  Node: Red-Black Trees,  Next: Threaded Binary Search Trees,  Prev: AVL Trees,  Up: Top

6 Red-Black Trees
*****************

The last chapter saw us implementing a library for one particular type
of balanced trees.  Red-black trees were invented by R. Bayer and
studied at length by L. J. Guibas and R. Sedgewick.  This chapter will
implement a library for another kind of balanced tree, called a
"red-black tree" (*note red-black tree::).  For brevity, we'll often
abbreviate "red-black" to RB.

   Insertion and deletion operations on red-black trees are more complex
to describe or to code than the same operations on AVL trees.
Red-black trees also have a higher maximum height than AVL trees for a
given number of nodes.  The primary advantage of red-black trees is
that, in AVL trees, deleting one node from a tree containing n nodes
may require log2 (n) rotations, but deletion in a red-black tree never
requires more than three rotations.

   The functions for RB trees in this chapter are analogous to those
that we developed for use with AVL trees in the previous chapter.
Here's an outline of the red-black code:

192. <rb.h 192> =
<*Note License: 1.>
#ifndef RB_H
#define RB_H 1

#include <stddef.h>

<*Note Table types; tbl => rb: 14.>
<*Note RB maximum height: 195.>
<*Note BST table structure; bst => rb: 27.>
<*Note RB node structure: 194.>
<*Note BST traverser structure; bst => rb: 61.>
<*Note Table function prototypes; tbl => rb: 15.>

#endif /* rb.h */

193. <rb.c 193> =
<*Note License: 1.>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "rb.h"

<*Note RB functions: 196.>

See also:  *Note Cormen 1990::, chapter 14, "Chapter notes."

* Menu:

* RB Balancing Rule::
* RB Data Types::
* Operations in an RB Tree::
* Inserting into an RB Tree::
* Deleting from an RB Tree::
* Testing RB Trees::


File: libavl.info,  Node: RB Balancing Rule,  Next: RB Data Types,  Prev: Red-Black Trees,  Up: Red-Black Trees

6.1 Balancing Rule
==================

To most clearly express the red-black balancing rule, we need a few new
vocabulary terms.  First, define a "non-branching node" as a node that
does not "branch" the binary tree in different directions, i.e., a node
with exactly zero or one children.

   Second, a "path" is a list of one or more nodes in a binary tree
where every node in the list (except the last node, of course) is
"adjacent" (*note adjacent::) in the tree to the one after it.  Two
nodes in a tree are considered to be adjacent for this purpose if one
is the child of the other.  Furthermore, a "simple path" is a path that
does not contain any given node more than once.

   Finally, a node p is a "descendant" of a second node q if both p and
q are the same node, or if p is located in one of the subtrees of q.

   With these definitions in mind, a red-black tree is a binary search
tree in which every node has been labeled with a "color" (*note
color::), either "red" or "black", with those colors distributed
according to these two simple rules, which are called the "red-black
balancing rules" and often referenced by number:

  1. No red node has a red child.

  2. Every simple path from a given node to one of its non-branching
     node descendants contains the same number of black nodes.

   Any binary search tree that conforms to these rules is a red-black
tree.  Additionally, all red-black trees in libavl share a simple
additional property: their roots are black.  This property is not
essential, but it does slightly simplify insertion and deletion
operations.

   To aid in digestion of all these definitions, here are some red-black
trees that might be produced by libavl:

 [image src="rbex.png" text="             4                                        1
            <b>                   4                  <b>
    ___..--'   \\                 <b>               _'   `---...___
    1            5         __..-'   `._            0               6
   <r>          <b>        3            6         <b>             <r>
 _'   `._                 <b>          <b>                  __..-'   \\
 0        3             _'   \\       _'   \\                 4          7
<b>      <b>            1      2     5      7              <b>        <b>
       _'              <r>    <r>   <r>    <r>           _'   \\
       2                                                 3      5
      <r>                                               <r>    <r>

" ]

In this book, black nodes are marked `b' and red nodes marked `r', as
shown here.

   The three colored BSTs below are *not* red-black trees.  The one on
the left violates rule 1, because red node 2 is a child of red node 4.
The one in the middle violates rule 2, because one path from the root
has two black nodes (4-2-3) and the other paths from the root down to a
non-branching node (4-2-1, 4-5, 4-5-6) have only one black node.  The
one on the right violates rule 2, because the path consisting of only
node 1 has only one black node but path 1-2 has two black nodes.

 [image src="rbctrex.png" text="                     4                    4
                    <r>                  <r>             1
              __..-'   \\           __..-'   \\           <b>
              2          5         2          5            \\
             <r>        <b>       <b>        <b>             2
           _'   \\               _'   \\          \\           <b>
           1      3             1      3          6
          <b>    <b>           <r>    <b>        <r>

" ]

See also:  *Note Cormen 1990::, section 14.1; *Note Sedgewick 1998::,
definitions 13.3 and 13.4.

Exercises:

*1. A red-black tree contains only black nodes.  Describe the tree's
shape.  [*Note answer: 6-1#1..]

2. Suppose that a red-black tree's root is red.  How can it be
transformed into a equivalent red-black tree with a black root?  Does a
similar procedure work for changing a RB's root from black to red?
[*Note answer: 6-1#2..]

3. Suppose we have a perfectly balanced red-black tree with exactly pow
(2, n) - 1 nodes and a black root.  Is it possible there is another way
to arrange colors in a tree of the same shape that obeys the red-black
rules while keeping the root black?  Is it possible if we drop the
requirement that the tree be balanced?  [*Note answer: 6-1#3..]

* Menu:

* Analysis of Red-Black Balancing Rule::


File: libavl.info,  Node: Analysis of Red-Black Balancing Rule,  Prev: RB Balancing Rule,  Up: RB Balancing Rule

6.1.1 Analysis
--------------

As we were for AVL trees, we're interested in what the red-black
balancing rule guarantees about performance.  Again, we'll simply state
the results:

     A red-black tree with n nodes has height at least log2 (n + 1) but
     no more than 2 * log2 (n + 1).  A red-black tree with height h has
     at least pow (2, h / 2) - 1 nodes but no more than pow (2, h) - 1.

     For comparison, an optimally balanced BST with n nodes has height
     ceil (log2 (n + 1)).  An optimally balanced BST with height h has
     between pow (2, h - 1) and pow (2, h) - 1 nodes.

See also:  *Note Cormen 1990::, lemma 14.1; *Note Sedgewick 1998::,
property 13.8.


File: libavl.info,  Node: RB Data Types,  Next: Operations in an RB Tree,  Prev: RB Balancing Rule,  Up: Red-Black Trees

6.2 Data Types
==============

Red-black trees need their own data structure.  Otherwise, there's no
appropriate place to store each node's color.  Here's a C type for a
color and a structure for an RB node, using the rb_ prefix that we've
adopted for this module:

194. <RB node structure 194> =
/* Color of a red-black node. */
enum rb_color
  {
    RB_BLACK,   /* Black. */
    RB_RED      /* Red. */
  };

/* A red-black tree node. */
struct rb_node
  {
    struct rb_node *rb_link[2];   /* Subtrees. */
    void *rb_data;                /* Pointer to data. */
    unsigned char rb_color;       /* Color. */
  };
   This code is included in *Note 192::.

   The maximum height for an RB tree is higher than for an AVL tree,
because in the worst case RB trees store nodes less efficiently:

195. <RB maximum height 195> =
/* Maximum RB height. */
#ifndef RB_MAX_HEIGHT
#define RB_MAX_HEIGHT 48
#endif
   This code is included in *Note 192::, *Note 333::, *Note 452::, and
*Note 551::.

   The other data structures for RB trees are the same as for BSTs or
AVL trees.

Exercises:

1. Why is it okay to have both an enumeration type and a structure
member named rb_color?  [*Note answer: 6-2#1..]


File: libavl.info,  Node: Operations in an RB Tree,  Next: Inserting into an RB Tree,  Prev: RB Data Types,  Up: Red-Black Trees

6.3 Operations
==============

Now we'll implement for RB trees all the operations that we did for
BSTs.  Everything but the insertion and deletion function can be
borrowed either from our BST or AVL tree functions.  The copy function
is an unusual case: we need it to copy colors, instead of balance
factors, between nodes, so we replace avl_balance by rb_color in the
macro expansion.

196. <RB functions 196> =
<*Note BST creation function; bst => rb: 30.>
<*Note BST search function; bst => rb: 31.>
<*Note RB item insertion function: 197.>
<*Note Table insertion convenience functions; tbl => rb: 592.>
<*Note RB item deletion function: 220.>
<*Note AVL traversal functions; avl => rb: 178.>
<*Note AVL copy function; avl => rb; avl_balance => rb_color: 185.>
<*Note BST destruction function; bst => rb: 84.>
<*Note Default memory allocation functions; tbl => rb: 6.>
<*Note Table assertion functions; tbl => rb: 594.>
   This code is included in *Note 193::.


File: libavl.info,  Node: Inserting into an RB Tree,  Next: Deleting from an RB Tree,  Prev: Operations in an RB Tree,  Up: Red-Black Trees

6.4 Insertion
=============

The steps for insertion into a red-black tree are similar to those for
insertion into an AVL tree:

  1. *Search* for the location to insert the new item.

  2. *Insert* the item.

  3. *Rebalance* the tree as necessary to satisfy the red-black balance
     condition.

   Red-black node colors don't need to be updated in the way that AVL
balance factors do, so there is no separate step for updating colors.

   Here's the outline of the function, expressed as code:

197. <RB item insertion function 197> =
void **
rb_probe (struct rb_table *tree, void *item)
{
  <*Note rb_probe() local variables: 198.>

  <*Note Step 1: Search RB tree for insertion point: 199.>
  <*Note Step 2: Insert RB node: 200.>
  <*Note Step 3: Rebalance after RB insertion: 201.>

  return &n->rb_data;
}
   This code is included in *Note 196::.

198. <rb_probe() local variables 198> =
struct rb_node *pa[RB_MAX_HEIGHT]; /* Nodes on stack. */
unsigned char da[RB_MAX_HEIGHT];   /* Directions moved from stack nodes. */
int k;                             /* Stack height. */

struct rb_node *p; /* Traverses tree looking for insertion point. */
struct rb_node *n; /* Newly inserted node. */

assert (tree != NULL && item != NULL);
   This code is included in *Note 33::, *Note 197::, and *Note 210::.

See also:  *Note Cormen 1990::, section 14.3; *Note Sedgewick 1998::,
program 13.6.

* Menu:

* Inserting an RB Node Step 1 - Search::
* Inserting an RB Node Step 2 - Insert::
* Inserting an RB Node Step 3 - Rebalance::
* RB Insertion Symmetric Case::
* Initial Black Insertion in an RB Tree::


File: libavl.info,  Node: Inserting an RB Node Step 1 - Search,  Next: Inserting an RB Node Step 2 - Insert,  Prev: Inserting into an RB Tree,  Up: Inserting into an RB Tree

6.4.1 Step 1: Search
--------------------

The first thing to do is to search for the point to insert the new
node.  In a manner similar to AVL deletion, we keep a stack of nodes
tracking the path followed to arrive at the insertion point, so that
later we can move up the tree in rebalancing.

199. <Step 1: Search RB tree for insertion point 199> =
pa[0] = (struct rb_node *) &tree->rb_root;
da[0] = 0;
k = 1;
for (p = tree->rb_root; p != NULL; p = p->rb_link[da[k - 1]])
  {
    int cmp = tree->rb_compare (item, p->rb_data, tree->rb_param);
    if (cmp == 0)
      return &p->rb_data;

    pa[k] = p;
    da[k++] = cmp > 0;
  }
   This code is included in *Note 197:: and *Note 210::.


File: libavl.info,  Node: Inserting an RB Node Step 2 - Insert,  Next: Inserting an RB Node Step 3 - Rebalance,  Prev: Inserting an RB Node Step 1 - Search,  Up: Inserting into an RB Tree

6.4.2 Step 2: Insert
--------------------

200. <Step 2: Insert RB node 200> =
n = pa[k - 1]->rb_link[da[k - 1]] =
  tree->rb_alloc->libavl_malloc (tree->rb_alloc, sizeof *n);
if (n == NULL)
  return NULL;

n->rb_data = item;
n->rb_link[0] = n->rb_link[1] = NULL;
n->rb_color = RB_RED;
tree->rb_count++;
tree->rb_generation++;
This code is included in *Note 197:: and *Note 210::.

Exercises:

1. Why are new nodes colored red, instead of black?  [*Note answer:
6-4-2#1..]


File: libavl.info,  Node: Inserting an RB Node Step 3 - Rebalance,  Next: RB Insertion Symmetric Case,  Prev: Inserting an RB Node Step 2 - Insert,  Up: Inserting into an RB Tree

6.4.3 Step 3: Rebalance
-----------------------

The code in step 2 that inserts a node always colors the new node red.
This means that rule 2 is always satisfied afterward (as long as it was
satisfied before we began).  On the other hand, rule 1 is broken if the
newly inserted node's parent was red.  In this latter case we must
rearrange or recolor the BST so that it is again an RB tree.

   This is what rebalancing does.  At each step in rebalancing, we have
the invariant that we just colored a node p red and that p's parent,
the node at the top of the stack, is also red, a rule 1 violation.  The
rebalancing step may either clear up the violation entirely, without
introducing any other violations, in which case we are done, or, if
that is not possible, it reduces the violation to a similar violation
of rule 1 higher up in the tree, in which case we go around again.

   In no case can we allow the rebalancing step to introduce a rule 2
violation, because the loop is not prepared to repair that kind of
problem: it does not fit the invariant.  If we allowed rule 2
violations to be introduced, we would have to write additional code to
recognize and repair those violations.  This extra code would be a
waste of space, because we can do just fine without it.  (Incidentally,
there is nothing magical about using a rule 1 violation as our
rebalancing invariant.  We could use a rule 2 violation as our
invariant instead, and in fact we will later write an alternate
implementation that does that, in order to show how it would be done.)

   Here is the rebalancing loop.  At each rebalancing step, it checks
that we have a rule 1 violation by checking the color of pa[k - 1], the
node on the top of the stack, and then divides into two cases, one for
rebalancing an insertion in pa[k - 1]'s left subtree and a symmetric
case for the right subtree.  After rebalancing it recolors the root of
the tree black just in case the loop changed it to red:

201. <Step 3: Rebalance after RB insertion 201> =
while (k >= 3 && pa[k - 1]->rb_color == RB_RED)
  {
    if (da[k - 2] == 0)
      {
        <*Note Left-side rebalancing after RB insertion: 202.>
      }
    else
      {
        <*Note Right-side rebalancing after RB insertion: 206.>
      }
  }
tree->rb_root->rb_color = RB_BLACK;
   This code is included in *Note 197::.

   Now for the real work.  We'll look at the left-side insertion case
only.  Consider the node that was just recolored red in the last
rebalancing step, or if this is the first rebalancing step, the newly
inserted node n.  The code does not name this node, but we will refer
to it here as q.  We know that q is red and, because the loop condition
was met, that its parent pa[k - 1] is red.  Therefore, due to rule 1,
q's grandparent, pa[k - 2], must be black.  After this, we have three
cases, distinguished by the following code:

202. <Left-side rebalancing after RB insertion 202> =
struct rb_node *y = pa[k - 2]->rb_link[1];
if (y != NULL && y->rb_color == RB_RED)
  {
    <*Note Case 1 in left-side RB insertion rebalancing: 203.>
  }
else
  {
    struct rb_node *x;

    if (da[k - 1] == 0)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in left-side RB insertion rebalancing: 205.>
      }

    <*Note Case 2 in left-side RB insertion rebalancing: 204.>
    break;
  }
   This code is included in *Note 201::.

Case 1: q's uncle is red
........................

If q has an "uncle" y, that is, its grandparent has a child on the side
opposite q, and y is red, then rearranging the tree's color scheme is
all that needs to be done, like this:

 [image src="rbins1.png" text="                       |                                 |
                    pa[k-2]                           pa[k-2]
                      <b>                               <r>
            ___..--'       `_                 ___..--'       `_
           pa[k-1]            y              pa[k-1]            y
             <r>             <r>   =>          <b>             <b>
       _.-'       \\         /   \\        _.-'       \\         /   \\
       q           c       d     e       q           c       d     e
      <r>                               <r>
     /   \\                             /   \\
    a     b                           a     b

" ]

Notice the neat way that this preserves the "black-height" (*note
black-height::), or the number of black nodes in any simple path from a
given node down to a node with 0 or 1 children, at pa[k - 2].  This
ensures that rule 2 is not violated.

   After the transformation, if node pa[k - 2]'s parent exists and is
red, then we have to move up the tree and try again.  The while loop
condition takes care of this test, so adjusting the stack is all that
has to be done in this code segment:

203. <Case 1 in left-side RB insertion rebalancing 203> =
pa[k - 1]->rb_color = y->rb_color = RB_BLACK;
pa[k - 2]->rb_color = RB_RED;
k -= 2;
   This code is included in *Note 202::, *Note 207::, *Note 342::, and
*Note 462::.

Case 2: q is the left child of pa[k - 1]
........................................

If q is the left child of its parent, then we can perform a right
rotation at q's grandparent, which we'll call x, and recolor a couple
of nodes.  Then we're all done, because we've satisfied both rules.
Here's a diagram of what's happened:

 [image src="rbins2.png" text="                                 |
                             pa[k-2],x              |
                                <b>                 y
                   ___...---'         \\            <b>
                  pa[k-1],y            d       _.-'   `_
                     <r>                 =>    q         x
              _.-'         \\                  <r>       <r>
              q             c                /   \\     /   \\
             <r>                            a     b   c     d
            /   \\
           a     b

" ]

There's no need to progress farther up the tree, because neither the
subtree's black-height nor its root's color have changed.  Here's the
corresponding code.  Bear in mind that the break statement is in the
enclosing code segment:

204. <Case 2 in left-side RB insertion rebalancing 204> =
x = pa[k - 2];
x->rb_color = RB_RED;
y->rb_color = RB_BLACK;

x->rb_link[0] = y->rb_link[1];
y->rb_link[1] = x;
pa[k - 3]->rb_link[da[k - 3]] = y;
   This code is included in *Note 202::, *Note 343::, and *Note 464::.

Case 3: q is the right child of pa[k - 1]
.........................................

The final case, where q is a right child, is really just a small
variant of case 2, so we can handle it by transforming it into case 2
and sharing code for that case.  To transform case 2 to case 3, we just
rotate left at q's parent, which is then treated as q.

   The diagram below shows the transformation from case 3 into case 2.
After this transformation, x is relabeled q and y's parent is labeled
x, then rebalancing continues as shown in the diagram for case 2, with
the exception that pa[k - 1] is not updated to correspond to y as shown
in that diagram.  That's okay because variable y has already been set
to point to the proper node.

 [image src="rbins3.png" text="                                 |                      |
                              pa[k-2]                  <b>
                                <b>                _.-'   \\
               _____.....----'       \\             y       d
              pa[k-1],x               d           <r>
                 <r>                    =>    _.-'   \\
             /         `_                     x       c
            a            q,y                 <r>
                         <r>                /   \\
                        /   \\              a     b
                       b     c

" ]

205. <Case 3 in left-side RB insertion rebalancing 205> =
x = pa[k - 1];
y = x->rb_link[1];
x->rb_link[1] = y->rb_link[0];
y->rb_link[0] = x;
pa[k - 2]->rb_link[0] = y;
This code is included in *Note 202::, *Note 344::, and *Note 466::.

Exercises:

1. Why is the test k >= 3 on the while loop valid?  (Hint: read the
code for step 4, below, first.)  [*Note answer: 6-4-3#1..]

2. Consider rebalancing case 2 and, in particular, what would happen if
the root of subtree d were red.  Wouldn't the rebalancing
transformation recolor x as red and thus cause a rule 1 violation?
[*Note answer: 6-4-3#2..]


File: libavl.info,  Node: RB Insertion Symmetric Case,  Next: Initial Black Insertion in an RB Tree,  Prev: Inserting an RB Node Step 3 - Rebalance,  Up: Inserting into an RB Tree

6.4.4 Symmetric Case
--------------------

206. <Right-side rebalancing after RB insertion 206> =
struct rb_node *y = pa[k - 2]->rb_link[0];
if (y != NULL && y->rb_color == RB_RED)
  {
    <*Note Case 1 in right-side RB insertion rebalancing: 207.>
  }
else
  {
    struct rb_node *x;

    if (da[k - 1] == 1)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in right-side RB insertion rebalancing: 209.>
      }

    <*Note Case 2 in right-side RB insertion rebalancing: 208.>
    break;
  }
This code is included in *Note 201::.

207. <Case 1 in right-side RB insertion rebalancing 207> =
<*Note Case 1 in left-side RB insertion rebalancing: 203.>
   This code is included in *Note 206::, *Note 346::, and *Note 463::.

208. <Case 2 in right-side RB insertion rebalancing 208> =
x = pa[k - 2];
x->rb_color = RB_RED;
y->rb_color = RB_BLACK;

x->rb_link[1] = y->rb_link[0];
y->rb_link[0] = x;
pa[k - 3]->rb_link[da[k - 3]] = y;
   This code is included in *Note 206::, *Note 347::, and *Note 465::.

209. <Case 3 in right-side RB insertion rebalancing 209> =
x = pa[k - 1];
y = x->rb_link[0];
x->rb_link[0] = y->rb_link[1];
y->rb_link[1] = x;
pa[k - 2]->rb_link[1] = y;
   This code is included in *Note 206::, *Note 348::, and *Note 467::.


File: libavl.info,  Node: Initial Black Insertion in an RB Tree,  Prev: RB Insertion Symmetric Case,  Up: Inserting into an RB Tree

6.4.5 Aside: Initial Black Insertion
------------------------------------

The traditional algorithm for insertion in an RB tree colors new nodes
red.  This is a good choice, because it often means that no rebalancing
is necessary, but it is not the only possible choice.  This section
implements an alternate algorithm for insertion into an RB tree that
colors new nodes black.

   The outline is the same as for initial-red insertion.  We change the
newly inserted node from red to black and replace the rebalancing
algorithm:

210. <RB item insertion function, initial black 210> =
void **
rb_probe (struct rb_table *tree, void *item)
{
  <*Note rb_probe() local variables: 198.>

  <*Note Step 1: Search RB tree for insertion point: 199.>
  <*Note Step 2: Insert RB node; RB_RED => RB_BLACK: 200.>
  <*Note Step 3: Rebalance after initial-black RB insertion: 211.>

  return &n->rb_data;
}

   The remaining task is to devise the rebalancing algorithm.
Rebalancing is always necessary, unless the tree was empty before
insertion, because insertion of a black node into a nonempty tree
always violates rule 2.  Thus, our invariant is that we have a rule 2
violation to fix.

   More specifically, the invariant, as implemented, is that at the top
of each trip through the loop, stack pa[] contains the chain of
ancestors of a node that is the black root of a subtree whose
black-height is 1 more than it should be.  We give that node the name
q.  There is one easy rebalancing special case: if node q has a black
parent, we can just recolor q as red, and we're done.  Here's the loop:

211. <Step 3: Rebalance after initial-black RB insertion 211> =
while (k >= 2)
  {
    struct rb_node *q = pa[k - 1]->rb_link[da[k - 1]];

    if (pa[k - 1]->rb_color == RB_BLACK)
      {
        q->rb_color = RB_RED;
        break;
      }

    if (da[k - 2] == 0)
      {
        <*Note Left-side rebalancing after initial-black RB insertion: 212.>
      }
    else
      {
        <*Note Right-side rebalancing after initial-black RB insertion: 216.>
      }
  }
   This code is included in *Note 210::.

   Consider rebalancing where insertion was on the left side of q's
grandparent.  We know that q is black and its parent pa[k - 1] is red.
Then, we can divide rebalancing into three cases, described below in
detail.  (For additional insight, compare these cases to the
corresponding cases for initial-red insertion.)

212. <Left-side rebalancing after initial-black RB insertion 212> =
struct rb_node *y = pa[k - 2]->rb_link[1];

if (y != NULL && y->rb_color == RB_RED)
  {
    <*Note Case 1 in left-side initial-black RB insertion rebalancing: 213.>
  }
else
  {
    struct rb_node *x;

    if (da[k - 1] == 0)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in left-side initial-black RB insertion rebalancing: 215.>
      }

    <*Note Case 2 in left-side initial-black RB insertion rebalancing: 214.>
  }
   This code is included in *Note 211::.

Case 1: q's uncle is red
........................

If q has an red "uncle" y, then we recolor q red and pa[k - 1] and y
black.  This fixes the immediate problem, making the black-height of q
equal to its sibling's, but increases the black-height of pa[k - 2], so
we must repeat the rebalancing process farther up the tree:

 [image src="rbib1.png" text="                       |                                 |
                    pa[k-2]                           pa[k-2]
                      <b>                               <b>
            ___..--'       `_                 ___..--'       `_
           pa[k-1]            y              pa[k-1]            y
             <r>             <r>   =>          <b>             <b>
       _.-'       \\         /   \\        _.-'       \\         /   \\
       q           c       d     e       q           c       d     e
      <b>                               <r>
     /   \\                             /   \\
    a     b                           a     b

" ]

213. <Case 1 in left-side initial-black RB insertion rebalancing 213> =
pa[k - 1]->rb_color = y->rb_color = RB_BLACK;
q->rb_color = RB_RED;
k -= 2;
This code is included in *Note 212:: and *Note 217::.

Case 2: q is the left child of pa[k - 1]
........................................

If q is a left child, then call q's parent y and its grandparent x,
rotate right at x, and recolor q, y, and x.  The effect is that the
black-heights of all three subtrees is the same as before q was
inserted, so we're done, and break out of the loop.

 [image src="rbib2.png" text="                                 |
                             pa[k-2],x              |
                                <b>                 y
                   ___...---'         \\            <b>
                  pa[k-1],y            d       _.-'   `_
                     <r>                 =>    q         x
              _.-'         \\                  <r>       <r>
              q             c                /   \\     /   \\
             <b>                            a     b   c     d
            /   \\
           a     b

" ]

214. <Case 2 in left-side initial-black RB insertion rebalancing 214> =
x = pa[k - 2];
x->rb_color = q->rb_color = RB_RED;
y->rb_color = RB_BLACK;

x->rb_link[0] = y->rb_link[1];
y->rb_link[1] = x;
pa[k - 3]->rb_link[da[k - 3]] = y;
break;
This code is included in *Note 212::.

Case 3: q is the right child of pa[k - 1]
.........................................

If q is a right child, then we rotate left at its parent, which we here
call x.  The result is in the form for application of case 2, so after
the rotation, we relabel the nodes to be consistent with that case.

 [image src="rbib3.png" text="                               |                        |
                            pa[k-2]                  pa[k-2]
                              <b>                      <b>
             _____.....----'       \\             _.-'       \\
            pa[k-1],x               d            q           d
               <r>                    =>        <b>
           /         `_                     _.-'   \\
          a             q                   x       c
                       <b>                 <r>
                      /   \\               /   \\
                     b     c             a     b

" ]

215. <Case 3 in left-side initial-black RB insertion rebalancing 215> =
x = pa[k - 1];
y = pa[k - 2]->rb_link[0] = q;
x->rb_link[1] = y->rb_link[0];
q = y->rb_link[0] = x;
This code is included in *Note 212::.

6.4.5.1 Symmetric Case
......................

216. <Right-side rebalancing after initial-black RB insertion 216> =
struct rb_node *y = pa[k - 2]->rb_link[0];

if (y != NULL && y->rb_color == RB_RED)
  {
    <*Note Case 1 in right-side initial-black RB insertion rebalancing: 217.>
  }
else
  {
    struct rb_node *x;

    if (da[k - 1] == 1)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in right-side initial-black RB insertion rebalancing: 219.>
      }

    <*Note Case 2 in right-side initial-black RB insertion rebalancing: 218.>
  }
This code is included in *Note 211::.

217. <Case 1 in right-side initial-black RB insertion rebalancing 217> =
<*Note Case 1 in left-side initial-black RB insertion rebalancing: 213.>
   This code is included in *Note 216::.

218. <Case 2 in right-side initial-black RB insertion rebalancing 218> =
x = pa[k - 2];
x->rb_color = q->rb_color = RB_RED;
y->rb_color = RB_BLACK;

x->rb_link[1] = y->rb_link[0];
y->rb_link[0] = x;
pa[k - 3]->rb_link[da[k - 3]] = y;
break;
   This code is included in *Note 216::.

219. <Case 3 in right-side initial-black RB insertion rebalancing 219> =
x = pa[k - 1];
y = pa[k - 2]->rb_link[1] = q;
x->rb_link[0] = y->rb_link[1];
q = y->rb_link[1] = x;
   This code is included in *Note 216::.


File: libavl.info,  Node: Deleting from an RB Tree,  Next: Testing RB Trees,  Prev: Inserting into an RB Tree,  Up: Red-Black Trees

6.5 Deletion
============

The process of deletion from an RB tree is very much in line with the
other algorithms for balanced trees that we've looked at already.  This
time, the steps are:

  1. *Search* for the item to delete.

  2. *Delete* the item.

  3. *Rebalance* the tree as necessary.

  4. *Finish up* and return.

   Here's an outline of the code.  Step 1 is already done for us,
because we can reuse the search code from AVL deletion.

220. <RB item deletion function 220> =
void *
rb_delete (struct rb_table *tree, const void *item)
{
  struct rb_node *pa[RB_MAX_HEIGHT]; /* Nodes on stack. */
  unsigned char da[RB_MAX_HEIGHT];   /* Directions moved from stack nodes. */
  int k;                             /* Stack height. */

  struct rb_node *p;    /* The node to delete, or a node part way to it. */
  int cmp;              /* Result of comparison between item and p. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search AVL tree for item to delete; avl => rb: 165.>
  <*Note Step 2: Delete item from RB tree: 221.>
  <*Note Step 3: Rebalance tree after RB deletion: 225.>
  <*Note Step 4: Finish up after RB deletion: 232.>
}
   This code is included in *Note 196::.

See also:  *Note Cormen 1990::, section 14.4.

* Menu:

* Deleting an RB Node Step 2 - Delete::
* Deleting an RB Node Step 3 - Rebalance::
* Deleting an RB Node Step 4 - Finish Up::
* RB Deletion Symmetric Case::


File: libavl.info,  Node: Deleting an RB Node Step 2 - Delete,  Next: Deleting an RB Node Step 3 - Rebalance,  Prev: Deleting from an RB Tree,  Up: Deleting from an RB Tree

6.5.1 Step 2: Delete
--------------------

At this point, p is the node to be deleted and the stack contains all
of the nodes on the simple path from the tree's root down to p.  The
immediate task is to delete p.  We break deletion down into the
familiar three cases (*note Deleting from a BST::), but before we dive
into the code, let's think about the situation.

   In red-black insertion, we were able to limit the kinds of violation
that could occur to rule 1 or rule 2, at our option, by choosing the
new node's color.  No such luxury is available in deletion, because
colors have already been assigned to all of the nodes.  In fact, a
naive approach to deletion can lead to multiple violations in widely
separated parts of a tree.  Consider the effects of deletion of node 3
from the following red-black tree tree, supposing that it is a subtree
of some larger tree:

 [image src="rbdeln1.png" text="                              |
                              3
                             <r>
                       __..-'   `----...._____
                       1                       8
                      <b>                     <b>
                    _'   \\              __..-'   \\
                    0      2            6          9
                   <b>    <b>          <r>        <b>
                                 __..-'   \\
                                 4          7
                                <b>        <b>
                                   \\
                                     5
                                    <r>

" ]

If we performed this deletion in a literal-minded fashion, we would end
up with the tree below, with the following violations: rule 1, between
node 6 and its child; rule 2, at node 6; rule 2, at node 4, because the
black-height of the subtree as a whole has increased (ignoring the rule
2 violation at node 6); and rule 1, at node 4, only if the subtree's
parent is red.  The result is difficult to rebalance in general because
we have two problem areas to deal with, one at node 4, one at node 6.

 [image src="rbdeln2.png" text="                                |
                                4
                               <b>
                         __..-'   `---...___
                         1                   8
                        <b>                 <b>
                      _'   \\          __..-'   \\
                      0      2        6          9
                     <b>    <b>      <r>        <b>
                                   _'   \\
                                   5      7
                                  <r>    <b>

" ]

Fortunately, we can make things easier for ourselves.  We can eliminate
the problem area at node 4 simply by recoloring it red, the same color
as the node it replaced, as shown below.  Then all we have to deal with
are the violations at node 6:

 [image src="rbdeln3.png" text="                                |
                                4
                               <r>
                         __..-'   `---...___
                         1                   8
                        <b>                 <b>
                      _'   \\          __..-'   \\
                      0      2        6          9
                     <b>    <b>      <r>        <b>
                                   _'   \\
                                   5      7
                                  <r>    <b>

" ]

This idea holds in general.  So, when we replace the deleted node p by
a different node q, we set q's color to p's.  Besides that, as an
implementation detail, we need to keep track of the color of the node
that was moved, i.e., node q's former color.  We do this here by saving
it temporarily in p.  In other words, when we replace one node by
another during deletion, we swap their colors.

   Now we know enough to begin the implementation.  While reading this
code, keep in mind that after deletion, regardless of the case
selected, the stack contains a list of the nodes where rebalancing may
be required, and da[k - 1] indicates the side of pa[k - 1] from which a
node of color p->rb_color was deleted.  Here's an outline of the meat
of the code:

221. <Step 2: Delete item from RB tree 221> =
if (p->rb_link[1] == NULL)
  { <*Note Case 1 in RB deletion: 222.> }
else
  {
    enum rb_color t;
    struct rb_node *r = p->rb_link[1];

    if (r->rb_link[0] == NULL)
      {
        <*Note Case 2 in RB deletion: 223.>
      }
    else
      {
        <*Note Case 3 in RB deletion: 224.>
      }
  }
   This code is included in *Note 220::.

Case 1: p has no right child
............................

In case 1, p has no right child, so we replace it by its left subtree.
As a very special case, there is no need to do any swapping of colors
(see Exercise 1 for details).

222. <Case 1 in RB deletion 222> =
pa[k - 1]->rb_link[da[k - 1]] = p->rb_link[0];
   This code is included in *Note 221::.

Case 2: p's right child has no left child
.........................................

In this case, p has a right child r, which in turn has no left child.
We replace p by r, swap the colors of nodes p and r, and add r to the
stack because we may need to rebalance there.  Here's a pre- and
post-deletion diagram that shows one possible set of colors out of the
possibilities.  Node p is shown detached after deletion to make it
clear that the colors are swapped:

 [image src="rbdelcase2.png" text="                         |              |
                         p              r        p
                        <r>            <r>      <b>
                       /   \\          /   \\
                      a      r    => a     x
                            <b>
                               \\
                                x

" ]

223. <Case 2 in RB deletion 223> =
r->rb_link[0] = p->rb_link[0];
t = r->rb_color;
r->rb_color = p->rb_color;
p->rb_color = t;
pa[k - 1]->rb_link[da[k - 1]] = r;
da[k] = 1;
pa[k++] = r;
This code is included in *Note 221::.

Case 3: p's right child has a left child
........................................

In this case, p's right child has a left child.  The code here is
basically the same as for AVL deletion.  We replace p by its inorder
successor s and swap their node colors.  Because they may require
rebalancing, we also add all of the nodes we visit to the stack.
Here's a diagram to clear up matters, again with arbitrary colors:

 [image src="rbdelcase3.png" text="            |                          |
            p                          s
           <b>                        <b>
          /   `----....____          /   `---...___
         a                 <r>      a              <r>
                         _'   \\                  _'   \\      p
                        ...    c                ...    c    <r>
                    _.-'         =>         _.-'
                    r                       r
                   <r>                     <r>
               _.-'   \\                   /   \\
               s       b                 x     b
              <b>
                 \\
                  x

" ]

224. <Case 3 in RB deletion 224> =
struct rb_node *s;
int j = k++;

for (;;)
  {
    da[k] = 0;
    pa[k++] = r;
    s = r->rb_link[0];
    if (s->rb_link[0] == NULL)
      break;

    r = s;
  }

da[j] = 1;
pa[j] = s;
pa[j - 1]->rb_link[da[j - 1]] = s;

s->rb_link[0] = p->rb_link[0];
r->rb_link[0] = s->rb_link[1];
s->rb_link[1] = p->rb_link[1];

t = s->rb_color;
s->rb_color = p->rb_color;
p->rb_color = t;
This code is included in *Note 221::.

Exercises:

*1. In case 1, why is it unnecessary to swap the colors of p and the
node that replaces it?  [*Note answer: 6-5-1#1..]

2. Rewrite <*Note Step 2: Delete item from RB tree: 221.> to replace
the deleted node's rb_data by its successor, then delete the successor,
instead of shuffling pointers.  (Refer back to Exercise 4.8-3 for an
explanation of why this approach cannot be used in libavl.)  [*Note
answer: 6-5-1#2..]


File: libavl.info,  Node: Deleting an RB Node Step 3 - Rebalance,  Next: Deleting an RB Node Step 4 - Finish Up,  Prev: Deleting an RB Node Step 2 - Delete,  Up: Deleting from an RB Tree

6.5.2 Step 3: Rebalance
-----------------------

At this point, node p has been removed from tree and p->rb_color
indicates the color of the node that was removed from the tree.  Our
first step is to handle one common special case: if we deleted a red
node, no rebalancing is necessary, because deletion of a red node
cannot violate either rule.  Here is the code to avoid rebalancing in
this special case:

225. <Step 3: Rebalance tree after RB deletion 225> =
if (p->rb_color == RB_BLACK)
  {
    <*Note Rebalance after RB deletion: 226.>
  }
   This code is included in *Note 220::.

   On the other hand, if a black node was deleted, then we have more
work to do.  At the least, we have a violation of rule 2.  If the
deletion brought together two red nodes, as happened in the example in
the previous section, there is also a violation of rule 1.

   We must now fix both of these problems by rebalancing.  This time,
the rebalancing loop invariant is that the black-height of pa[k - 1]'s
subtree on side da[k - 1] is 1 less than the black-height of its other
subtree, a rule 2 violation.

   There may also be a rule 2 violation, such pa[k - 1] and its child
on side da[k - 1], which we will call x, are both red.  (In the first
iteration of the rebalancing loop, node x is the node labeled as such
in the diagrams in the previous section.)  If this is the case, then
the fix for rule 2 is simple: just recolor x black.  This increases the
black-height and fixes any rule 1 violation as well.  If we can do
this, we're all done.  Otherwise, we have more work to do.

   Here's the rebalancing loop:

226. <Rebalance after RB deletion 226> =
for (;;)
  {
    struct rb_node *x = pa[k - 1]->rb_link[da[k - 1]];
    if (x != NULL && x->rb_color == RB_RED)
      {
        x->rb_color = RB_BLACK;
        break;
      }
    if (k < 2)
      break;

    if (da[k - 1] == 0)
      {
        <*Note Left-side rebalancing after RB deletion: 227.>
      }
    else
      {
        <*Note Right-side rebalancing after RB deletion: 233.>
      }

    k-;
  }
   This code is included in *Note 225::.

   Now we'll take a detailed look at the rebalancing algorithm.  As
before, we'll only examine the case where the deleted node was in its
parent's left subtree, that is, where da[k - 1] is 0.  The other case
is similar.

   Recall that x is pa[k - 1]->rb_link[da[k - 1]] and that it may be a
null pointer.  In the left-side deletion case, x is pa[k - 1]'s left
child.  We now designate x's "sibling", the right child of pa[k - 1],
as w.  Jumping right in, here's an outline of the rebalancing code:

227. <Left-side rebalancing after RB deletion 227> =
struct rb_node *w = pa[k - 1]->rb_link[1];

if (w->rb_color == RB_RED)
  {
    <*Note Ensure w is black in left-side RB deletion rebalancing: 228.>
  }

if ((w->rb_link[0] == NULL
     || w->rb_link[0]->rb_color == RB_BLACK)
    && (w->rb_link[1] == NULL
        || w->rb_link[1]->rb_color == RB_BLACK))
  { <*Note Case 1 in left-side RB deletion rebalancing: 229.> }
else
  {
    if (w->rb_link[1] == NULL
        || w->rb_link[1]->rb_color == RB_BLACK)
      {
        <*Note Transform left-side RB deletion rebalancing case 3 into case 2: 231.>
      }

    <*Note Case 2 in left-side RB deletion rebalancing: 230.>
    break;
  }
   This code is included in *Note 226::.

Case Reduction: Ensure w is black
.................................

We know, at this point, that x is a black node or an empty tree.  Node
w may be red or black.  If w is red, we perform a left rotation at the
common parent of x and w, labeled A in the diagram below, and recolor A
and its own newly acquired parent C.  Then we reassign w as the new
sibling of x.  The effect is to ensure that w is also black, in order
to reduce the number of cases:

 [image src="rbdel1.png" text="         |                                               |
     A,pa[k-1]                                       C,pa[k-2]
        <b>                                             <b>
    /         `--..__                 _____.....----'         `_
   x                 C,w             A,pa[k-1]                   D
                     <r>        =>      <r>                     <b>
                 _.-'   `_          /         `_               /   \\
                 B         D       x            B,w           c     d
                <b>       <b>                   <b>
               /   \\     /   \\                 /   \\
              a     b   c     d               a     b

" ]

Node w must have children because x is black, in order to satisfy rule
2, and w's children must be black because of rule 1.

   Here is the code corresponding to this transformation.  Because the
ancestors of node x change, pa[] and da[] are updated as well as w.

228. <Ensure w is black in left-side RB deletion rebalancing 228> =
w->rb_color = RB_BLACK;
pa[k - 1]->rb_color = RB_RED;

pa[k - 1]->rb_link[1] = w->rb_link[0];
w->rb_link[0] = pa[k - 1];
pa[k - 2]->rb_link[da[k - 2]] = w;

pa[k] = pa[k - 1];
da[k] = 0;
pa[k - 1] = w;
k++;

w = pa[k - 1]->rb_link[1];
   This code is included in *Note 227::, *Note 358::, and *Note 475::.

   Now we can take care of the three rebalancing cases one by one.
Remember that the situation is a deleted black node in the subtree
designated x and the goal is to correct a rule 2 violation.  Although
subtree x may be an empty tree, the diagrams below show it as a black
node.  That's okay because the code itself never refers to x.  The
label is supplied for the reader's benefit only.

Case 1: w has no red children
.............................

If w doesn't have any red children, then it can be recolored red.  When
we do that, the black-height of the subtree rooted at w has decreased,
so we must move up the tree, with pa[k - 1] becoming the new x, to
rebalance at w and x's parent.

   The parent, labeled B in the diagram below, may be red or black.
Its color is not changed within the code for this case.  If it is red,
then the next iteration of the rebalancing loop will recolor it as red
immediately and exit.  In particular, B will be red if the
transformation to make x black was performed earlier.  If, on the other
hand, B is black, the loop will continue as usual.

 [image src="rbdel2.png" text="                         |                       |
                     B,pa[k-1]                  B,x
                        <g>                     <g>
                 _.-'         `_            _.-'   `_
                A,x             C,w   =>    A         C
                <b>             <b>        <b>       <r>
               /   \\           /   \\      /   \\     /   \\
              a     b         c     d    a     b   c     d

" ]

229. <Case 1 in left-side RB deletion rebalancing 229> =
w->rb_color = RB_RED;
This code is included in *Note 227::, *Note 359::, *Note 475::, and
*Note 574::.

Case 2: w's right child is red
..............................

If w's right child is red, we can perform a left rotation at pa[k - 1]
and recolor some nodes, and thereby satisfy both of the red-black
rules.  The loop is then complete.  The transformation looks like this:

 [image src="rbdel3.png" text="                    |                                 |
                B,pa[x-1]                             C
                   <g>                               <g>
            _.-'         `_                      _.-'   `_
           A,x             C,w                   B         D
           <b>             <b>        =>        <b>       <b>
          /   \\           /   `_            _.-'   \\     /   \\
         a     b         c       D          A       c   d     e
                                <r>        <b>
                               /   \\      /   \\
                              d     e    a     b

" ]

The corresponding code is below.  The break is supplied by the
enclosing code segment <*Note Left-side rebalancing after RB deletion:
227.>:

230. <Case 2 in left-side RB deletion rebalancing 230> =
w->rb_color = pa[k - 1]->rb_color;
pa[k - 1]->rb_color = RB_BLACK;
w->rb_link[1]->rb_color = RB_BLACK;

pa[k - 1]->rb_link[1] = w->rb_link[0];
w->rb_link[0] = pa[k - 1];
pa[k - 2]->rb_link[da[k - 2]] = w;
   This code is included in *Note 227::, *Note 360::, and *Note 477::.

Case 3: w's left child is red
.............................

Because the conditions for neither case 1 nor case 2 apply, the only
remaining possibility is that w has a red left child.  When this is the
case, we can transform it into case 2 by rotating right at w.  This
causes w to move to the node that was previously w's left child, in
this way:

 [image src="rbdel4.png" text="                 |                               |
             B,pa[k-1]                       B,pa[k-1]
                <g>                             <g>
         _.-'         `--..__            _.-'         `_
        A,x                  D,w        A,x             C,w
        <b>                  <b>   =>   <b>             <b>
       /   \\             _.-'   \\      /   \\           /   `_
      a     b            C       e    a     b         c       D
                        <r>                                  <r>
                       /   \\                                /   \\
                      c     d                              d     e

" ]

231. <Transform left-side RB deletion rebalancing case 3 into case 2 231> =
struct rb_node *y = w->rb_link[0];
y->rb_color = RB_BLACK;
w->rb_color = RB_RED;
w->rb_link[0] = y->rb_link[1];
y->rb_link[1] = w;
w = pa[k - 1]->rb_link[1] = y;
This code is included in *Note 227::, *Note 361::, and *Note 479::.


File: libavl.info,  Node: Deleting an RB Node Step 4 - Finish Up,  Next: RB Deletion Symmetric Case,  Prev: Deleting an RB Node Step 3 - Rebalance,  Up: Deleting from an RB Tree

6.5.3 Step 4: Finish Up
-----------------------

All that's left to do is free the node, update counters, and return the
deleted item:

232. <Step 4: Finish up after RB deletion 232> =
tree->rb_alloc->libavl_free (tree->rb_alloc, p);
tree->rb_count-;
tree->rb_generation++;
return (void *) item;
   This code is included in *Note 220::.


File: libavl.info,  Node: RB Deletion Symmetric Case,  Prev: Deleting an RB Node Step 4 - Finish Up,  Up: Deleting from an RB Tree

6.5.4 Symmetric Case
--------------------

233. <Right-side rebalancing after RB deletion 233> =
struct rb_node *w = pa[k - 1]->rb_link[0];

if (w->rb_color == RB_RED)
  {
    <*Note Ensure w is black in right-side RB deletion rebalancing: 234.>
  }

if ((w->rb_link[0] == NULL
     || w->rb_link[0]->rb_color == RB_BLACK)
    && (w->rb_link[1] == NULL
        || w->rb_link[1]->rb_color == RB_BLACK))
  { <*Note Case 1 in right-side RB deletion rebalancing: 235.> }
else
  {
    if (w->rb_link[0] == NULL
        || w->rb_link[0]->rb_color == RB_BLACK)
      {
        <*Note Transform right-side RB deletion rebalancing case 3 into case 2: 236.>
      }

    <*Note Case 2 in right-side RB deletion rebalancing: 237.>
    break;
  }
This code is included in *Note 226::.

234. <Ensure w is black in right-side RB deletion rebalancing 234> =
w->rb_color = RB_BLACK;
pa[k - 1]->rb_color = RB_RED;

pa[k - 1]->rb_link[0] = w->rb_link[1];
w->rb_link[1] = pa[k - 1];
pa[k - 2]->rb_link[da[k - 2]] = w;

pa[k] = pa[k - 1];
da[k] = 1;
pa[k - 1] = w;
k++;

w = pa[k - 1]->rb_link[0];
   This code is included in *Note 233::, *Note 364::, and *Note 476::.

235. <Case 1 in right-side RB deletion rebalancing 235> =
w->rb_color = RB_RED;
   This code is included in *Note 233::, *Note 365::, and *Note 476::.

236. <Transform right-side RB deletion rebalancing case 3 into case 2 236> =
struct rb_node *y = w->rb_link[1];
y->rb_color = RB_BLACK;
w->rb_color = RB_RED;
w->rb_link[1] = y->rb_link[0];
y->rb_link[0] = w;
w = pa[k - 1]->rb_link[0] = y;
   This code is included in *Note 233::, *Note 367::, and *Note 480::.

237. <Case 2 in right-side RB deletion rebalancing 237> =
w->rb_color = pa[k - 1]->rb_color;
pa[k - 1]->rb_color = RB_BLACK;
w->rb_link[0]->rb_color = RB_BLACK;

pa[k - 1]->rb_link[0] = w->rb_link[1];
w->rb_link[1] = pa[k - 1];
pa[k - 2]->rb_link[da[k - 2]] = w;
   This code is included in *Note 233::, *Note 366::, and *Note 478::.


File: libavl.info,  Node: Testing RB Trees,  Prev: Deleting from an RB Tree,  Up: Red-Black Trees

6.6 Testing
===========

Now we'll present a test program to demonstrate that our code works,
using the same framework that has been used in past chapters.  The
additional code needed is straightforward:

238. <rb-test.c 238> =
<*Note License: 1.>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "rb.h"
#include "test.h"

<*Note BST print function; bst => rb: 119.>
<*Note BST traverser check function; bst => rb: 104.>
<*Note Compare two RB trees for structure and content: 239.>
<*Note Recursively verify RB tree structure: 240.>
<*Note RB tree verify function: 244.>
<*Note BST test function; bst => rb: 100.>
<*Note BST overflow test function; bst => rb: 122.>

239. <Compare two RB trees for structure and content 239> =
static int
compare_trees (struct rb_node *a, struct rb_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      assert (a == NULL && b == NULL);
      return 1;
    }

  if (*(int *) a->rb_data != *(int *) b->rb_data
      || ((a->rb_link[0] != NULL) != (b->rb_link[0] != NULL))
      || ((a->rb_link[1] != NULL) != (b->rb_link[1] != NULL))
      || a->rb_color != b->rb_color)
    {
      printf (" Copied nodes differ: a=%d%c b=%d%c a:",
              *(int *) a->rb_data, a->rb_color == RB_RED ? 'r' : 'b',
              *(int *) b->rb_data, b->rb_color == RB_RED ? 'r' : 'b');

      if (a->rb_link[0] != NULL)
        printf ("l");
      if (a->rb_link[1] != NULL)
        printf ("r");

      printf (" b:");
      if (b->rb_link[0] != NULL)
        printf ("l");
      if (b->rb_link[1] != NULL)
        printf ("r");

      printf ("\n");
      return 0;
    }

  okay = 1;
  if (a->rb_link[0] != NULL)
    okay &= compare_trees (a->rb_link[0], b->rb_link[0]);
  if (a->rb_link[1] != NULL)
    okay &= compare_trees (a->rb_link[1], b->rb_link[1]);
  return okay;
}
   This code is included in *Note 238::.

240. <Recursively verify RB tree structure 240> =
/* Examines the binary tree rooted at node.
   Zeroes *okay if an error occurs.
   Otherwise, does not modify *okay.
   Sets *count to the number of nodes in that tree,
   including node itself if node != NULL.
   Sets *bh to the tree's black-height.
   All the nodes in the tree are verified to be at least min
   but no greater than max. */
static void
recurse_verify_tree (struct rb_node *node, int *okay, size_t *count,
                     int min, int max, int *bh)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */
  int subbh[2];         /* Black-heights of subtrees. */

  if (node == NULL)
    {
      *count = 0;
      *bh = 0;
      return;
    }
  d = *(int *) node->rb_data;

  <*Note Verify binary search tree ordering: 114.>

  recurse_verify_tree (node->rb_link[0], okay, &subcount[0],
                       min, d - 1, &subbh[0]);
  recurse_verify_tree (node->rb_link[1], okay, &subcount[1],
                       d + 1, max, &subbh[1]);
  *count = 1 + subcount[0] + subcount[1];
  *bh = (node->rb_color == RB_BLACK) + subbh[0];

  <*Note Verify RB node color: 241.>
  <*Note Verify RB node rule 1 compliance: 242.>
  <*Note Verify RB node rule 2 compliance: 243.>
}
   This code is included in *Note 238::.

241. <Verify RB node color 241> =
if (node->rb_color != RB_RED && node->rb_color != RB_BLACK)
  {
    printf (" Node %d is neither red nor black (%d).\n",
            d, node->rb_color);
    *okay = 0;
  }
   This code is included in *Note 240::, *Note 370::, *Note 484::, and
*Note 585::.

242. <Verify RB node rule 1 compliance 242> =
/* Verify compliance with rule 1. */
if (node->rb_color == RB_RED)
  {
    if (node->rb_link[0] != NULL && node->rb_link[0]->rb_color == RB_RED)
      {
        printf (" Red node %d has red left child %d\n",
                d, *(int *) node->rb_link[0]->rb_data);
        *okay = 0;
      }

    if (node->rb_link[1] != NULL && node->rb_link[1]->rb_color == RB_RED)
      {
        printf (" Red node %d has red right child %d\n",
                d, *(int *) node->rb_link[1]->rb_data);
        *okay = 0;
      }
  }
   This code is included in *Note 240:: and *Note 585::.

243. <Verify RB node rule 2 compliance 243> =
/* Verify compliance with rule 2. */
if (subbh[0] != subbh[1])
  {
    printf (" Node %d has two different blackheights: left bh=%d, "
            "right bh=%d\n", d, subbh[0], subbh[1]);
    *okay = 0;
  }
   This code is included in *Note 240::, *Note 370::, *Note 484::, and
*Note 585::.

244. <RB tree verify function 244> =
static int
verify_tree (struct rb_table *tree, int array[], size_t n)
{
  int okay = 1;

  <*Note Check tree->bst_count is correct; bst => rb: 110.>

  if (okay)
    {
      <*Note Check root is black: 245.>
    }

  if (okay)
    {
      <*Note Check RB tree structure: 246.>
    }

  if (okay)
    {
      <*Note Check that the tree contains all the elements it should; bst => rb: 115.>
    }

  if (okay)
    {
      <*Note Check that forward traversal works; bst => rb: 116.>
    }

  if (okay)
    {
      <*Note Check that backward traversal works; bst => rb: 117.>
    }

  if (okay)
    {
      <*Note Check that traversal from the null element works; bst => rb: 118.>
    }

  return okay;
}
   This code is included in *Note 238::, *Note 368::, *Note 482::, and
*Note 583::.

245. <Check root is black 245> =
if (tree->rb_root != NULL && tree->rb_root->rb_color != RB_BLACK)
  {
    printf (" Tree's root is not black.\n");
    okay = 0;
  }
   This code is included in *Note 244::.

246. <Check RB tree structure 246> =
/* Recursively verify tree structure. */
size_t count;
int bh;

recurse_verify_tree (tree->rb_root, &okay, &count, 0, INT_MAX, &bh);
<*Note Check counted nodes: 112.>
   This code is included in *Note 244::.


File: libavl.info,  Node: Threaded Binary Search Trees,  Next: Threaded AVL Trees,  Prev: Red-Black Trees,  Up: Top

7 Threaded Binary Search Trees
******************************

Traversal in inorder, as done by libavl traversers, is a common
operation in a binary tree.  To do this efficiently in an ordinary
binary search tree or balanced tree, we need to maintain a list of the
nodes above the current node, or at least a list of nodes still to be
visited.  This need leads to the stack used in struct bst_traverser and
friends.

   It's really too bad that we need such stacks for traversal.  First,
they take up space.  Second, they're fragile: if an item is inserted
into or deleted from the tree during traversal, or if the tree is
balanced, we have to rebuild the traverser's stack.  In addition, it
can sometimes be difficult to know in advance how tall the stack will
need to be, as demonstrated by the code that we wrote to handle stack
overflow.

   These problems are important enough that, in this book, we'll look at
two different solutions.  This chapter looks at the first of these,
which adds special pointers, each called a "thread" (*note thread::),
to nodes, producing what is called a threaded binary search tree,
"threaded tree" (*note threaded tree::), or simply a TBST.(1)  Later in
the book, we'll examine an alternate and more general solution using a
"parent pointer" (*note parent pointer::) in each node.

   Here's the outline of the TBST code.  We're using the prefix tbst_
this time:

247. <tbst.h 247> =
<*Note License: 1.>
#ifndef TBST_H
#define TBST_H 1

#include <stddef.h>

<*Note Table types; tbl => tbst: 14.>
<*Note TBST table structure: 250.>
<*Note TBST node structure: 249.>
<*Note TBST traverser structure: 267.>
<*Note Table function prototypes; tbl => tbst: 15.>
<*Note BST extra function prototypes; bst => tbst: 88.>

#endif /* tbst.h */

248. <tbst.c 248> =
<*Note License: 1.>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "tbst.h"

<*Note TBST functions: 251.>

* Menu:

* Threads::
* TBST Data Types::
* TBST Operations::
* Creating a TBST::
* Searching a TBST::
* Inserting into a TBST::
* Deleting from a TBST::
* Traversing a TBST::
* Copying a TBST::
* Destroying a TBST::
* Balancing a TBST::
* Testing TBSTs::

   ---------- Footnotes ----------

   (1) This usage of "thread" has nothing to do with the idea of a
program with multiple "threads of excecution", a form of multitasking
within a single program.


File: libavl.info,  Node: Threads,  Next: TBST Data Types,  Prev: Threaded Binary Search Trees,  Up: Threaded Binary Search Trees

7.1 Threads
===========

In an ordinary binary search tree or balanced tree, a lot of the pointer
fields go more-or-less unused.  Instead of pointing to somewhere useful,
they are used to store null pointers.  In a sense, they're wasted.  What
if we were to instead use these fields to point elsewhere in the tree?

   This is the idea behind a threaded tree.  In a threaded tree, a
node's left child pointer field, if it would otherwise be a null
pointer, is used to point to the node's inorder predecessor.  An
otherwise-null right child pointer field points to the node's
successor.  The least-valued node in a threaded tree has a null pointer
for its left thread, and the greatest-valued node similarly has a null
right thread.  These two are the only null pointers in a threaded tree.

   Here's a sample threaded tree:

 [image src="tbst1.png" text="                           3
                       _.-' `---....____
                      2                 6
                  _.-' \\        ___..--' `--..___
                 1      [3]    4                 8
                / \\          _' `._          _.-' `._
               []  [2]      [3]    5        7        9
                                 _' \\     _' \\     _' \\
                                [4]  [6] [6]  [8] [8]  []

" ]

This diagram illustrates the convention used for threads in text:
thread links are designated by surrounding the node name or value with
square brackets.  Null threads in the least and greatest nodes are
shown as `[0]', which is also used to show threads up to nodes not
shown in the diagram.  This notation is unfortunate, but less visually
confusing than trying to include additional arrows in text art tree
diagrams.

There are some disadvantages to threaded trees.  Each node in an
unthreaded tree has only one pointer that leads to it, either from the
tree structure or its parent node, but in a threaded tree some nodes
have as many as three pointers leading to them: one from the root or
parent, one from its predecessor's right thread, and one from its
successor's left thread.  This means that, although traversing a
threaded tree is simpler, building and maintaining a threaded tree is
more complicated.

   As we learned earlier, any node that has a right child has a
successor in its right subtree, and that successor has no left child.
So, a node in an threaded tree has a left thread pointing back to it if
and only if the node has a right child.  Similarly, a node has a right
thread pointing to it if and only if the node has a left child.  Take a
look at the sample tree above and check these statements for yourself
for some of its nodes.

See also:  *Note Knuth 1997::, section 2.3.1.


File: libavl.info,  Node: TBST Data Types,  Next: TBST Operations,  Prev: Threads,  Up: Threaded Binary Search Trees

7.2 Data Types
==============

We need two extra fields in the node structure to keep track of whether
each link is a child pointer or a thread.  Each of these fields is
called a "tag" (*note tag::).  The revised struct tbst_node, along with
enum tbst_tag for tags, looks like this:

249. <TBST node structure 249> =
/* Characterizes a link as a child pointer or a thread. */
enum tbst_tag
  {
    TBST_CHILD,                     /* Child pointer. */
    TBST_THREAD                     /* Thread. */
  };

/* A threaded binary search tree node. */
struct tbst_node
  {
    struct tbst_node *tbst_link[2]; /* Subtrees. */
    void *tbst_data;                /* Pointer to data. */
    unsigned char tbst_tag[2];      /* Tag fields. */
  };
   This code is included in *Note 247::.

Each element of tbst_tag[] is set to TBST_CHILD if the corresponding
tbst_link[] element is a child pointer, or to TBST_THREAD if it is a
thread.  The other members of struct tbst_node should be familiar.

   We also want a revised table structure, because traversers in
threaded trees do not need a generation number:

250. <TBST table structure 250> =
/* Tree data structure. */
struct tbst_table
  {
    struct tbst_node *tbst_root;        /* Tree's root. */
    tbst_comparison_func *tbst_compare; /* Comparison function. */
    void *tbst_param;                   /* Extra argument to tbst_compare. */
    struct libavl_allocator *tbst_alloc; /* Memory allocator. */
    size_t tbst_count;                  /* Number of items in tree. */
  };
   This code is included in *Note 247::, *Note 297::, *Note 333::,
*Note 372::, *Note 415::, *Note 452::, *Note 486::, *Note 519::, and
*Note 551::.

   There is no need to define a maximum height for TBST trees because
none of the TBST functions use a stack.

Exercises:

1. We defined enum tbst_tag for distinguishing threads from child
pointers, but declared the actual tag members as unsigned char instead.
Why?  [*Note answer: 7-2#1..]


File: libavl.info,  Node: TBST Operations,  Next: Creating a TBST,  Prev: TBST Data Types,  Up: Threaded Binary Search Trees

7.3 Operations
==============

Now that we've changed the basic form of our binary trees, we have to
rewrite most of the tree functions.  A function designed for use with
unthreaded trees will get hopelessly lost in a threaded tree, because
it will follow threads that it thinks are child pointers.  The only
functions we can keep are the totally generic functions defined in
terms of other table functions.

251. <TBST functions 251> =
<*Note TBST creation function: 252.>
<*Note TBST search function: 253.>
<*Note TBST item insertion function: 254.>
<*Note Table insertion convenience functions; tbl => tbst: 592.>
<*Note TBST item deletion function: 257.>
<*Note TBST traversal functions: 268.>
<*Note TBST copy function: 278.>
<*Note TBST destruction function: 281.>
<*Note TBST balance function: 282.>
<*Note Default memory allocation functions; tbl => tbst: 6.>
<*Note Table assertion functions; tbl => tbst: 594.>
   This code is included in *Note 248::.


File: libavl.info,  Node: Creating a TBST,  Next: Searching a TBST,  Prev: TBST Operations,  Up: Threaded Binary Search Trees

7.4 Creation
============

Function tbst_create() is the same as bst_create() except that a struct
tbst_table has no generation number to fill in.

252. <TBST creation function 252> =
struct tbst_table *
tbst_create (tbst_comparison_func *compare, void *param,
            struct libavl_allocator *allocator)
{
  struct tbst_table *tree;

  assert (compare != NULL);

  if (allocator == NULL)
    allocator = &tbst_allocator_default;

  tree = allocator->libavl_malloc (allocator, sizeof *tree);
  if (tree == NULL)
    return NULL;

  tree->tbst_root = NULL;
  tree->tbst_compare = compare;
  tree->tbst_param = param;
  tree->tbst_alloc = allocator;
  tree->tbst_count = 0;

  return tree;
}
   This code is included in *Note 251::, *Note 300::, *Note 336::,
*Note 375::, *Note 418::, *Note 455::, *Note 489::, *Note 522::, and
*Note 554::.


File: libavl.info,  Node: Searching a TBST,  Next: Inserting into a TBST,  Prev: Creating a TBST,  Up: Threaded Binary Search Trees

7.5 Search
==========

In searching a TBST we just have to be careful to distinguish threads
from child pointers.  If we hit a thread link, then we've run off the
bottom of the tree and the search is unsuccessful.  Other that that, a
search in a TBST works the same as in any other binary search tree.

253. <TBST search function 253> =
void *
tbst_find (const struct tbst_table *tree, const void *item)
{
  const struct tbst_node *p;

  assert (tree != NULL && item != NULL);

  p = tree->tbst_root;
  if (p == NULL)
    return NULL;

  for (;;)
    {
      int cmp, dir;

      cmp = tree->tbst_compare (item, p->tbst_data, tree->tbst_param);
      if (cmp == 0)
        return p->tbst_data;

      dir = cmp > 0;
      if (p->tbst_tag[dir] == TBST_CHILD)
        p = p->tbst_link[dir];
      else
        return NULL;
    }
}
   This code is included in *Note 251::, *Note 300::, and *Note 336::.


File: libavl.info,  Node: Inserting into a TBST,  Next: Deleting from a TBST,  Prev: Searching a TBST,  Up: Threaded Binary Search Trees

7.6 Insertion
=============

It take a little more effort to insert a new node into a threaded BST
than into an unthreaded one, but not much more.  The only difference is
that we now have to set up the new node's left and right threads to
point to its predecessor and successor, respectively.

   Fortunately, these are easy to figure out.  Suppose that new node n
is the right child of its parent p (the other case is symmetric).  This
means that p is n's predecessor, because n is the least node in p's
right subtree.  Moreover, n's successor is the node that was p's
successor before n was inserted, that is to say, it is the same as p's
former right thread.

   Here's an example that may help to clear up the description.  When
new node 3 is inserted as the right child of 2, its left thread points
to 2 and its right thread points where 2's right thread formerly did,
to 4:

 [image src="tbstins.png" text="                           6                                    6
                   ___..--' \\                           ___..--' \\
                  4          []                        4          []
            __..-' `._                     ____....---' `._
           2,p        5         =>        2,p              5
       _.-'   \\     _' \\              _.-'   `._         _' \\
      1        [4] [4]  [6]          1          3,n     [4]  [6]
     / \\                            / \\       _'   \\
    []  [2]                        []  [2]   [2]    [4]

" ]

The following code unifies the left-side and right-side cases using
dir, which takes the value 1 for a right-side insertion, 0 for a
left-side insertion.  The side opposite dir can then be expressed
simply as !dir.

254. <TBST item insertion function 254> =
void **
tbst_probe (struct tbst_table *tree, void *item)
{
  struct tbst_node *p; /* Traverses tree to find insertion point. */
  struct tbst_node *n; /* New node. */
  int dir;             /* Side of p on which n is inserted. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search TBST for insertion point: 255.>
  <*Note Step 2: Insert TBST node: 256.>

  return &n->tbst_data;
}
   This code is included in *Note 251::.

255. <Step 1: Search TBST for insertion point 255> =
if (tree->tbst_root != NULL)
  for (p = tree->tbst_root; ; p = p->tbst_link[dir])
    {
      int cmp = tree->tbst_compare (item, p->tbst_data, tree->tbst_param);
      if (cmp == 0)
        return &p->tbst_data;
      dir = cmp > 0;

      if (p->tbst_tag[dir] == TBST_THREAD)
        break;
    }
else
  {
    p = (struct tbst_node *) &tree->tbst_root;
    dir = 0;
  }
   This code is included in *Note 254:: and *Note 668::.

256. <Step 2: Insert TBST node 256> =
n = tree->tbst_alloc->libavl_malloc (tree->tbst_alloc, sizeof *n);
if (n == NULL)
  return NULL;

tree->tbst_count++;
n->tbst_data = item;
n->tbst_tag[0] = n->tbst_tag[1] = TBST_THREAD;
n->tbst_link[dir] = p->tbst_link[dir];
if (tree->tbst_root != NULL)
  {
    p->tbst_tag[dir] = TBST_CHILD;
    n->tbst_link[!dir] = p;
  }
else
  n->tbst_link[1] = NULL;
p->tbst_link[dir] = n;
   This code is included in *Note 254::, *Note 303::, and *Note 339::.

See also:  *Note Knuth 1997::, algorithm 2.3.1I.

Exercises:

1. What happens if we reverse the order of the final if statement above
and the following assignment?  [*Note answer: 7-6#1..]


File: libavl.info,  Node: Deleting from a TBST,  Next: Traversing a TBST,  Prev: Inserting into a TBST,  Up: Threaded Binary Search Trees

7.7 Deletion
============

When we delete a node from a threaded tree, we have to update one or two
more pointers than if it were an unthreaded BST.  What's more, we
sometimes have to go to a bit of effort to track down what pointers
these are, because they are in the predecessor and successor of the node
being deleted.

   The outline is the same as for deleting a BST node:

257. <TBST item deletion function 257> =
void *
tbst_delete (struct tbst_table *tree, const void *item)
{
  struct tbst_node *p;	/* Node to delete. */
  struct tbst_node *q;	/* Parent of p. */
  int dir;              /* Index into q->tbst_link[] that leads to p. */

  assert (tree != NULL && item != NULL);

  <*Note Find TBST node to delete: 258.>
  <*Note Delete TBST node: 259.>
  <*Note Finish up after deleting TBST node: 266.>
}
   This code is included in *Note 251::.

   We search down the tree to find the item to delete, p.  As we do it
we keep track of its parent q and the direction dir that we descended
from it.  The initial value of q and dir use the trick seen originally
in copying a BST (*note Copying a BST Iteratively::).

   There are nicer ways to do the same thing, though they are not
necessarily as efficient.  See the exercises for one possibility.

258. <Find TBST node to delete 258> =
if (tree->tbst_root == NULL)
  return NULL;

p = tree->tbst_root;
q = (struct tbst_node *) &tree->tbst_root;
dir = 0;
for (;;)
  {
    int cmp = tree->tbst_compare (item, p->tbst_data, tree->tbst_param);
    if (cmp == 0)
      break;

    dir = cmp > 0;
    if (p->tbst_tag[dir] == TBST_THREAD)
      return NULL;

    q = p;
    p = p->tbst_link[dir];
  }
item = p->tbst_data;
   This code is included in *Note 257::.

   The cases for deletion from a threaded tree are a bit different from
those for an unthreaded tree.  The key point to keep in mind is that a
node with n children has n threads pointing to it that must be updated
when it is deleted.  Let's look at the cases in detail now.

   Here's the outline:

259. <Delete TBST node 259> =
if (p->tbst_tag[1] == TBST_THREAD)
  {
    if (p->tbst_tag[0] == TBST_CHILD)
      {
        <*Note Case 1 in TBST deletion: 260.>
      }
    else
      {
        <*Note Case 2 in TBST deletion: 261.>
      }
  }
else
  {
    struct tbst_node *r = p->tbst_link[1];
    if (r->tbst_tag[0] == TBST_THREAD)
      {
        <*Note Case 3 in TBST deletion: 262.>
      }
    else
      {
        <*Note Case 4 in TBST deletion: 263.>
      }
  }
   This code is included in *Note 257::.

Case 1: p has a right thread and a left child
.............................................

If p has a right thread and a left child, then we replace it by its
left child.  We also replace its predecessor t's right thread by p's
right thread.  In the most general subcase, the whole operation looks
something like this:

 [image src="tbstdel1.png" text="                                 |
                                 q                    |
                             _.-' \\                   q
                            p      []       ___...---' \\
                  ___...---' \\             s            []
                 s            [q]         / `_
                / `_                  => r    u
               r    u                        / `_
                   / `_                     t    x
                  t    x                        / \\
                      / \\                      v   [q]
                     v   [p]

" ]

On the other hand, it can be as simple as this:

 [image src="tbstdel1triv.png" text="                                 |
                                 q              |
                             _.-' \\             q
                            p      []       _.-' \\
                        _.-' \\        =>   x      []
                       x      [q]         / \\
                      / \\                []  [q]
                     []  [p]

" ]

Both of these subcases, and subcases in between them in complication,
are handled by the same code:

260. <Case 1 in TBST deletion 260> =
struct tbst_node *t = p->tbst_link[0];
while (t->tbst_tag[1] == TBST_CHILD)
  t = t->tbst_link[1];
t->tbst_link[1] = p->tbst_link[1];
q->tbst_link[dir] = p->tbst_link[0];
   This code is included in *Note 259:: and *Note 314::.

Case 2: p has a right thread and a left thread
..............................................

If p is a leaf, then no threads point to it, but we must change its
parent q's pointer to p to a thread, pointing to the same place that
the corresponding thread of p pointed.  This is easy, and typically
looks something like this:

 [image src="tbstdel2.png" text="                            |
                            q             |
                           / `._          q
                          []    p    =>  / \\
                              _' \\      []  []
                             [q]  []

" ]

There is one special case, which comes up when q is the pseudo-node
used for the parent of the root.  We can't access tbst_tag[] in this
"node".  Here's the code:

261. <Case 2 in TBST deletion 261> =
q->tbst_link[dir] = p->tbst_link[dir];
if (q != (struct tbst_node *) &tree->tbst_root)
  q->tbst_tag[dir] = TBST_THREAD;
   This code is included in *Note 259:: and *Note 315::.

Case 3: p's right child has a left thread
.........................................

If p has a right child r, and r itself has a left thread, then we
delete p by moving r into its place.  Here's an example where the root
node is deleted:

 [image src="tbstdel3.png" text="            2,p
        _.-'   `._                              3,r
       1          3,r                       _.-'   `--..___
      / \\       _'   `--..___              1               5
     []  [2]   [2]           5        =>  / \\          _.-' `._
                         _.-' `._        []  [3]      4        6
                        4        6                  _' \\     _' \\
                      _' \\     _' \\                [3]  [5] [5]  []
                     [3]  [5] [5]  []

" ]

This just involves changing q's right link to point to r, copying p's
left link and tag into r, and fixing any thread that pointed to p so
that it now points to r.  The code is straightforward:

262. <Case 3 in TBST deletion 262> =
r->tbst_link[0] = p->tbst_link[0];
r->tbst_tag[0] = p->tbst_tag[0];
if (r->tbst_tag[0] == TBST_CHILD)
  {
    struct tbst_node *t = r->tbst_link[0];
    while (t->tbst_tag[1] == TBST_CHILD)
      t = t->tbst_link[1];
    t->tbst_link[1] = r;
  }
q->tbst_link[dir] = r;
   This code is included in *Note 259:: and *Note 316::.

Case 4: p's right child has a left child
........................................

If p has a right child, which in turn has a left child, we arrive at
the most complicated case.  It corresponds to case 3 in deletion from
an unthreaded BST.  The solution is to find p's successor s and move it
in place of p.  In this case, r is s's parent node, not necessarily p's
right child.

   There are two subcases here.  In the first, s has a right child.  In
that subcase, s's own successor's left thread already points to s, so
we need not adjust any threads.  Here's an example of this subcase.
Notice how the left thread of node 3, s's successor, already points to
s.

 [image src="tbstdel4.png" text="         1,p
     _.-'   `------......._______               2,s
    0                            5          _.-'   `----....._____
   / \\                     __..-' \\        0                      5
  []  [1]                 4,r      []     / \\               __..-' \\
                ___...---'   \\        => []  [2]           4,r      []
               2,s            [5]                      _.-'   \\
             _'   `._                                 3        [5]
            [1]      3                              _' \\
                   _' \\                            [2]  [4]
                  [2]  [4]

" ]

The second subcase comes up when s has a right thread.  Because s also
has a left thread, this means that s is a leaf.  This subcase requires
us to change r's left link to a thread to its predecessor, which is now
s.  Here's a continuation of the previous example, showing deletion of
the new root, node 2:

 [image src="tbstdel4-2.png" text="              2,p
          _.-'   `-----.....______               3,s
         0                        5          _.-'   `---...___
        / \\                 __..-' \\        0                 5
       []  [2]             4,r      [] =>  / \\          __..-' \\
                     __..-'   \\           []  [3]      4,r      []
                    3,s        [5]                   _'   \\
                  _'   \\                            [3]    [5]
                 [2]    [4]

" ]

The first part of the code handles finding r and s:

263. <Case 4 in TBST deletion 263> =
struct tbst_node *s;

for (;;)
  {
    s = r->tbst_link[0];
    if (s->tbst_tag[0] == TBST_THREAD)
      break;

    r = s;
  }
   See also *Note 264:: and *Note 265::.
This code is included in *Note 259:: and *Note 317::.

   Next, we update r, handling each of the subcases:

264. <Case 4 in TBST deletion 263> +=
if (s->tbst_tag[1] == TBST_CHILD)
  r->tbst_link[0] = s->tbst_link[1];
else
  {
    r->tbst_link[0] = s;
    r->tbst_tag[0] = TBST_THREAD;
  }

   Finally, we copy p's links and tags into s and chase down and update
any right thread in s's left subtree, then replace the pointer from q
down to s:

265. <Case 4 in TBST deletion 263> +=
s->tbst_link[0] = p->tbst_link[0];
if (p->tbst_tag[0] == TBST_CHILD)
  {
    struct tbst_node *t = p->tbst_link[0];
    while (t->tbst_tag[1] == TBST_CHILD)
      t = t->tbst_link[1];
    t->tbst_link[1] = s;

    s->tbst_tag[0] = TBST_CHILD;
  }

s->tbst_link[1] = p->tbst_link[1];
s->tbst_tag[1] = TBST_CHILD;

q->tbst_link[dir] = s;

   We finish up by deallocating the node, decrementing the tree's item
count, and returning the deleted item's data:

266. <Finish up after deleting TBST node 266> =
tree->tbst_alloc->libavl_free (tree->tbst_alloc, p);
tree->tbst_count-;
return (void *) item;
   This code is included in *Note 257::.

Exercises:

*1. In a threaded BST, there is an efficient algorithm to find the
parent of a given node.  Use this algorithm to reimplement <*Note Find
TBST node to delete: 258.>.  [*Note answer: 7-7#1..]

2. In case 2, we must handle q as the pseudo-root as a special case.
Can we rearrange the TBST data structures to avoid this?  [*Note
answer: 7-7#2..]

3. Rewrite case 4 to replace the deleted node's tbst_data by its
successor and actually delete the successor, instead of moving around
pointers.  (Refer back to Exercise 4.8-3 for an explanation of why this
approach cannot be used in libavl.)  [*Note answer: 7-7#3..]

*4. Many of the cases in deletion from a TBST require searching down the
tree for the nodes with threads to the deleted node.  Show that this
adds only a constant number of operations to the deletion of a randomly
selected node, compared to a similar deletion in an unthreaded tree.
[*Note answer: 7-7#4..]


File: libavl.info,  Node: Traversing a TBST,  Next: Copying a TBST,  Prev: Deleting from a TBST,  Up: Threaded Binary Search Trees

7.8 Traversal
=============

Traversal in a threaded BST is much simpler than in an unthreaded one.
This is, indeed, much of the point to threading our trees.  This section
implements all of the libavl traverser functions for threaded trees.

   Suppose we wish to find the successor of an arbitrary node in a
threaded tree.  If the node has a right child, then the successor is
the smallest item in the node's right subtree.  Otherwise, the node has
a right thread, and its sucessor is simply the node to which the right
thread points.  If the right thread is a null pointer, then the node is
the largest in the tree.  We can find the node's predecessor in a
similar manner.

   We don't ever need to know the parent of a node to traverse the
threaded tree, so there's no need to keep a stack.  Moreover, because a
traverser has no stack to be corrupted by changes to its tree, there is
no need to keep or compare generation numbers.  Therefore, this is all
we need for a TBST traverser structure:

267. <TBST traverser structure 267> =
/* TBST traverser structure. */
struct tbst_traverser
  {
    struct tbst_table *tbst_table;        /* Tree being traversed. */
    struct tbst_node *tbst_node;          /* Current node in tree. */
  };
   This code is included in *Note 247::, *Note 297::, *Note 333::,
*Note 372::, *Note 415::, *Note 452::, *Note 486::, *Note 519::, and
*Note 551::.

   The traversal functions are collected together here.  A few of the
functions are implemented directly in terms of their unthreaded BST
counterparts, but most must be reimplemented:

268. <TBST traversal functions 268> =
<*Note TBST traverser null initializer: 269.>
<*Note TBST traverser first initializer: 270.>
<*Note TBST traverser last initializer: 271.>
<*Note TBST traverser search initializer: 272.>
<*Note TBST traverser insertion initializer: 273.>
<*Note TBST traverser copy initializer: 274.>
<*Note TBST traverser advance function: 275.>
<*Note TBST traverser back up function: 276.>
<*Note BST traverser current item function; bst => tbst: 74.>
<*Note BST traverser replacement function; bst => tbst: 75.>
   This code is included in *Note 251::, *Note 300::, and *Note 336::.

See also:  *Note Knuth 1997::, algorithm 2.3.1S.

* Menu:

* TBST Traverser Null Initialization::
* TBST Traverser First Initialization::
* TBST Traverser Last Initialization::
* TBST Traverser Find Initialization::
* TBST Traverser Insert Initialization::
* TBST Traverser Copying::
* TBST Traverser Advancing::
* TBST Traverser Retreating::


File: libavl.info,  Node: TBST Traverser Null Initialization,  Next: TBST Traverser First Initialization,  Prev: Traversing a TBST,  Up: Traversing a TBST

7.8.1 Starting at the Null Node
-------------------------------

269. <TBST traverser null initializer 269> =
void
tbst_t_init (struct tbst_traverser *trav, struct tbst_table *tree)
{
  trav->tbst_table = tree;
  trav->tbst_node = NULL;
}
This code is included in *Note 268::, *Note 395::, *Note 502::, and
*Note 546::.


File: libavl.info,  Node: TBST Traverser First Initialization,  Next: TBST Traverser Last Initialization,  Prev: TBST Traverser Null Initialization,  Up: Traversing a TBST

7.8.2 Starting at the First Node
--------------------------------

270. <TBST traverser first initializer 270> =
void *
tbst_t_first (struct tbst_traverser *trav, struct tbst_table *tree)
{
  assert (tree != NULL && trav != NULL);

  trav->tbst_table = tree;
  trav->tbst_node = tree->tbst_root;
  if (trav->tbst_node != NULL)
    {
      while (trav->tbst_node->tbst_tag[0] == TBST_CHILD)
        trav->tbst_node = trav->tbst_node->tbst_link[0];
      return trav->tbst_node->tbst_data;
    }
  else
    return NULL;
}
This code is included in *Note 268::.


File: libavl.info,  Node: TBST Traverser Last Initialization,  Next: TBST Traverser Find Initialization,  Prev: TBST Traverser First Initialization,  Up: Traversing a TBST

7.8.3 Starting at the Last Node
-------------------------------

271. <TBST traverser last initializer 271> =
void *
tbst_t_last (struct tbst_traverser *trav, struct tbst_table *tree)
{
  assert (tree != NULL && trav != NULL);

  trav->tbst_table = tree;
  trav->tbst_node = tree->tbst_root;
  if (trav->tbst_node != NULL)
    {
      while (trav->tbst_node->tbst_tag[1] == TBST_CHILD)
        trav->tbst_node = trav->tbst_node->tbst_link[1];
      return trav->tbst_node->tbst_data;
    }
  else
    return NULL;
}
This code is included in *Note 268::.


File: libavl.info,  Node: TBST Traverser Find Initialization,  Next: TBST Traverser Insert Initialization,  Prev: TBST Traverser Last Initialization,  Up: Traversing a TBST

7.8.4 Starting at a Found Node
------------------------------

The code for this function is derived with few changes from <*Note TBST
search function: 253.>.

272. <TBST traverser search initializer 272> =
void *
tbst_t_find (struct tbst_traverser *trav, struct tbst_table *tree, void *item)
{
  struct tbst_node *p;

  assert (trav != NULL && tree != NULL && item != NULL);

  trav->tbst_table = tree;
  trav->tbst_node = NULL;

  p = tree->tbst_root;
  if (p == NULL)
    return NULL;

  for (;;)
    {
      int cmp, dir;

      cmp = tree->tbst_compare (item, p->tbst_data, tree->tbst_param);
      if (cmp == 0)
        {
          trav->tbst_node = p;
          return p->tbst_data;
        }

      dir = cmp > 0;
      if (p->tbst_tag[dir] == TBST_CHILD)
        p = p->tbst_link[dir];
      else
        return NULL;
    }
}
   This code is included in *Note 268::.


File: libavl.info,  Node: TBST Traverser Insert Initialization,  Next: TBST Traverser Copying,  Prev: TBST Traverser Find Initialization,  Up: Traversing a TBST

7.8.5 Starting at an Inserted Node
----------------------------------

This implementation is a trivial adaptation of <*Note AVL traverser
insertion initializer: 179.>.  In particular, management of generation
numbers has been removed.

273. <TBST traverser insertion initializer 273> =
void *
tbst_t_insert (struct tbst_traverser *trav,
               struct tbst_table *tree, void *item)
{
  void **p;

  assert (trav != NULL && tree != NULL && item != NULL);

  p = tbst_probe (tree, item);
  if (p != NULL)
    {
      trav->tbst_table = tree;
      trav->tbst_node =
        ((struct tbst_node *)
         ((char *) p - offsetof (struct tbst_node, tbst_data)));
      return *p;
    }
  else
    {
      tbst_t_init (trav, tree);
      return NULL;
    }
}
   This code is included in *Note 268::, *Note 395::, and *Note 546::.


File: libavl.info,  Node: TBST Traverser Copying,  Next: TBST Traverser Advancing,  Prev: TBST Traverser Insert Initialization,  Up: Traversing a TBST

7.8.6 Initialization by Copying
-------------------------------

274. <TBST traverser copy initializer 274> =
void *
tbst_t_copy (struct tbst_traverser *trav, const struct tbst_traverser *src)
{
  assert (trav != NULL && src != NULL);

  trav->tbst_table = src->tbst_table;
  trav->tbst_node = src->tbst_node;

  return trav->tbst_node != NULL ? trav->tbst_node->tbst_data : NULL;
}
This code is included in *Note 268::, *Note 395::, *Note 502::, and
*Note 546::.


File: libavl.info,  Node: TBST Traverser Advancing,  Next: TBST Traverser Retreating,  Prev: TBST Traverser Copying,  Up: Traversing a TBST

7.8.7 Advancing to the Next Node
--------------------------------

Despite the earlier discussion (*note Traversing a TBST::), there are
actually three cases, not two, in advancing within a threaded binary
tree.  The extra case turns up when the current node is the null item.
We deal with that case by calling out to tbst_t_first().

   Notice also that, below, in the case of following a thread we must
check for a null node, but not in the case of following a child pointer.

275. <TBST traverser advance function 275> =
void *
tbst_t_next (struct tbst_traverser *trav)
{
  assert (trav != NULL);

  if (trav->tbst_node == NULL)
    return tbst_t_first (trav, trav->tbst_table);
  else if (trav->tbst_node->tbst_tag[1] == TBST_THREAD)
    {
      trav->tbst_node = trav->tbst_node->tbst_link[1];
      return trav->tbst_node != NULL ? trav->tbst_node->tbst_data : NULL;
    }
  else
    {
      trav->tbst_node = trav->tbst_node->tbst_link[1];
      while (trav->tbst_node->tbst_tag[0] == TBST_CHILD)
        trav->tbst_node = trav->tbst_node->tbst_link[0];
      return trav->tbst_node->tbst_data;
    }
}
   This code is included in *Note 268::.

See also:  *Note Knuth 1997::, algorithm 2.3.1S.


File: libavl.info,  Node: TBST Traverser Retreating,  Prev: TBST Traverser Advancing,  Up: Traversing a TBST

7.8.8 Backing Up to the Previous Node
-------------------------------------

276. <TBST traverser back up function 276> =
void *
tbst_t_prev (struct tbst_traverser *trav)
{
  assert (trav != NULL);

  if (trav->tbst_node == NULL)
    return tbst_t_last (trav, trav->tbst_table);
  else if (trav->tbst_node->tbst_tag[0] == TBST_THREAD)
    {
      trav->tbst_node = trav->tbst_node->tbst_link[0];
      return trav->tbst_node != NULL ? trav->tbst_node->tbst_data : NULL;
    }
  else
    {
      trav->tbst_node = trav->tbst_node->tbst_link[0];
      while (trav->tbst_node->tbst_tag[1] == TBST_CHILD)
        trav->tbst_node = trav->tbst_node->tbst_link[1];
      return trav->tbst_node->tbst_data;
    }
}
This code is included in *Note 268::.


File: libavl.info,  Node: Copying a TBST,  Next: Destroying a TBST,  Prev: Traversing a TBST,  Up: Threaded Binary Search Trees

7.9 Copying
===========

We can use essentially the same algorithm to copy threaded BSTs as
unthreaded (see <*Note BST copy function: 83.>).  Some modifications are
necessary, of course.  The most obvious change is that the threads must
be set up.  This is not hard.  We can do it the same way that
tbst_probe() does.

   Less obvious is the way to get rid of the stack.  In bst_copy(), the
stack was used to keep track of as yet incompletely processed parents of
the current node.  When we came back to one of these nodes, we did the
actual copy of the node data, then visited the node's right subtree, if
non-empty.

   In a threaded tree, we can replace the use of the stack by the use of
threads.  Instead of popping an item off the stack when we can't move
down in the tree any further, we follow the node's right thread.  This
brings us up to an ancestor (parent, grandparent, ...) of the node,
which we can then deal with in the same way as before.

   This diagram shows the threads that would be followed to find
parents in copying a couple of different threaded binary trees.  Of
course, the TBSTs would have complete sets of threads, but only the
ones that are followed are shown:

 [image src="tbstcopy.png" text="                                                      5
                 4                          ___...---' `--..__
           __..-' `-.__                    2                  8
          2            6               _.-' `-.__       __..-' \\
      _.-' \\       _.-' \\             1          4     6        9
     1      3     5      7        _.-' \\     _.-' \\     \\        \\
      \\      \\     \\      \\      0      [2] 3      [5]   7        []
       [2]    [4]   [6]    []     \\          \\            \\
                                   [1]        [4]          [8]

" ]

Why does following the right thread from a node bring us to one of the
node's ancestors?  Consider the algorithm for finding the successor of
a node with no right child, described earlier (*note Better Iterative
Traversal::).  This algorithm just moves up the tree from a node to its
parent, grandparent, etc., guaranteeing that the successor will be a
ancestor of the original node.

   How do we know that following the right thread won't take us too far
up the tree and skip copying some subtree?  Because we only move up to
the right one time using that same algorithm.  When we move up to the
left, we're going back to some binary tree whose right subtree we've
already dealt with (we are currently in the right subtree of that
binary tree, so of course we've dealt with it).

   In conclusion, following the right thread always takes us to just the
node whose right subtree we want to copy next.  Of course, if that node
happens to have an empty right subtree, then there is nothing to do, so
we just continue along the next right thread, and so on.

   The first step is to build a function to copy a single node.  The
following function copy_node() does this, creating a new node as the
child of an existing node:

277. <TBST node copy function 277> =
/* Creates a new node as a child of dst on side dir.
   Copies data from src into the new node, applying copy(), if non-null.
   Returns nonzero only if fully successful.
   Regardless of success, integrity of the tree structure is assured,
   though failure may leave a null pointer in a tbst_data member. */
static int
copy_node (struct tbst_table *tree,
           struct tbst_node *dst, int dir,
           const struct tbst_node *src, tbst_copy_func *copy)
{
  struct tbst_node *new =
    tree->tbst_alloc->libavl_malloc (tree->tbst_alloc, sizeof *new);
  if (new == NULL)
    return 0;

  new->tbst_link[dir] = dst->tbst_link[dir];
  new->tbst_tag[dir] = TBST_THREAD;
  new->tbst_link[!dir] = dst;
  new->tbst_tag[!dir] = TBST_THREAD;
  dst->tbst_link[dir] = new;
  dst->tbst_tag[dir] = TBST_CHILD;

  if (copy == NULL)
    new->tbst_data = src->tbst_data;
  else
    {
      new->tbst_data = copy (src->tbst_data, tree->tbst_param);
      if (new->tbst_data == NULL)
        return 0;
    }

  return 1;
}
   This code is included in *Note 278::.

   Using the node copy function above, constructing the tree copy
function is easy.  In fact, the code is considerably easier to read
than our original function to iteratively copy an unthreaded binary tree
(*note Handling Errors in Iterative BST Copying::), because this
function is not as heavily optimized.

   One tricky part is getting the copy started.  We can't use the dirty
trick from bst_copy() of casting the address of a bst_root to a node
pointer, because we need access to the first tag as well as the first
link (see Exercise 2 for a way to sidestep this problem).  So instead
we use a couple of "pseudo-root" nodes rp and rq, allocated locally.

278. <TBST copy function 278> =
<*Note TBST node copy function: 277.>
<*Note TBST copy error helper function: 280.>
<*Note TBST main copy function: 279.>
   This code is included in *Note 251::.

279. <TBST main copy function 279> =
struct tbst_table *
tbst_copy (const struct tbst_table *org, tbst_copy_func *copy,
          tbst_item_func *destroy, struct libavl_allocator *allocator)
{
  struct tbst_table *new;

  const struct tbst_node *p;
  struct tbst_node *q;
  struct tbst_node rp, rq;

  assert (org != NULL);
  new = tbst_create (org->tbst_compare, org->tbst_param,
                     allocator != NULL ? allocator : org->tbst_alloc);
  if (new == NULL)
    return NULL;

  new->tbst_count = org->tbst_count;
  if (new->tbst_count == 0)
    return new;

  p = &rp;
  rp.tbst_link[0] = org->tbst_root;
  rp.tbst_tag[0] = TBST_CHILD;

  q = &rq;
  rq.tbst_link[0] = NULL;
  rq.tbst_tag[0] = TBST_THREAD;

  for (;;)
    {
      if (p->tbst_tag[0] == TBST_CHILD)
        {
          if (!copy_node (new, q, 0, p->tbst_link[0], copy))
            {
              copy_error_recovery (rq.tbst_link[0], new, destroy);
              return NULL;
            }

          p = p->tbst_link[0];
          q = q->tbst_link[0];
        }
      else
        {
          while (p->tbst_tag[1] == TBST_THREAD)
            {
              p = p->tbst_link[1];
              if (p == NULL)
                {
                  q->tbst_link[1] = NULL;
                  new->tbst_root = rq.tbst_link[0];
                  return new;
                }

              q = q->tbst_link[1];
            }

          p = p->tbst_link[1];
          q = q->tbst_link[1];
        }

      if (p->tbst_tag[1] == TBST_CHILD)
        if (!copy_node (new, q, 1, p->tbst_link[1], copy))
          {
            copy_error_recovery (rq.tbst_link[0], new, destroy);
            return NULL;
          }
    }
}
   This code is included in *Note 278:: and *Note 329::.

   A sensitive issue in the code above is treatment of the final thread.
The initial call to copy_node() causes a right thread to point to rq,
but it needs to be a null pointer.  We need to perform this kind of
transformation:

 [image src="tbstcopy2.png" text="                                 rq                            rq
               ______......-----'              _____.....-----'
              2                               2
          _.-' `--..___                   _.-' `--..___
         1             4            =>   1             4
        / \\        _.-' `._             / \\        _.-' `._
       []  [2]    3        5           []  [2]    3        5
                _' \\     _' \\                   _' \\     _' \\
               [2]  [4] [4]  [rq]              [2]  [4] [4]  []

" ]

When the copy is successful, this is just a matter of setting the final
q's right child pointer to NULL, but when it is unsuccessful we have to
find the pointer in question, which is in the greatest node in the tree
so far (to see this, try constructing a few threaded BSTs by hand on
paper).  Function copy_error_recovery() does this, as well as
destroying the tree.  It also handles the case of failure when no nodes
have yet been added to the tree:

280. <TBST copy error helper function 280> =
static void
copy_error_recovery (struct tbst_node *p,
                     struct tbst_table *new, tbst_item_func *destroy)
{
  new->tbst_root = p;
  if (p != NULL)
    {
      while (p->tbst_tag[1] == TBST_CHILD)
        p = p->tbst_link[1];
      p->tbst_link[1] = NULL;
    }
  tbst_destroy (new, destroy);
}
   This code is included in *Note 278:: and *Note 329::.

Exercises:

1. In the diagram above that shows examples of threads followed while
copying a TBST, all right threads in the TBSTs are shown.  Explain how
this is not just a coincidence.  [*Note answer: 7-9#1..]

2. Suggest some optimization possibilities for tbst_copy().  [*Note
answer: 7-9#2..]


File: libavl.info,  Node: Destroying a TBST,  Next: Balancing a TBST,  Prev: Copying a TBST,  Up: Threaded Binary Search Trees

7.10 Destruction
================

Destroying a threaded binary tree is easy.  We can simply traverse the
tree in inorder in the usual way.  We always have a way to get to the
next node without having to go back up to any of the nodes we've already
destroyed.  (We do, however, have to make sure to go find the next node
before destroying the current one, in order to avoid reading data from
freed memory.)  Here's all it takes:

281. <TBST destruction function 281> =
void
tbst_destroy (struct tbst_table *tree, tbst_item_func *destroy)
{
  struct tbst_node *p; /* Current node. */
  struct tbst_node *n; /* Next node. */

  p = tree->tbst_root;
  if (p != NULL)
    while (p->tbst_tag[0] == TBST_CHILD)
      p = p->tbst_link[0];

  while (p != NULL)
    {
      n = p->tbst_link[1];
      if (p->tbst_tag[1] == TBST_CHILD)
        while (n->tbst_tag[0] == TBST_CHILD)
          n = n->tbst_link[0];

      if (destroy != NULL && p->tbst_data != NULL)
        destroy (p->tbst_data, tree->tbst_param);
      tree->tbst_alloc->libavl_free (tree->tbst_alloc, p);

      p = n;
    }

  tree->tbst_alloc->libavl_free (tree->tbst_alloc, tree);
}
   This code is included in *Note 251::, *Note 300::, and *Note 336::.


File: libavl.info,  Node: Balancing a TBST,  Next: Testing TBSTs,  Prev: Destroying a TBST,  Up: Threaded Binary Search Trees

7.11 Balance
============

Just like their unthreaded cousins, threaded binary trees can become
degenerate, leaving their good performance characteristics behind.  When
this happened in a unthreaded BST, stack overflow often made it
necessary to rebalance the tree.  This doesn't happen in our
implementation of threaded BSTs, because none of the routines uses a
stack.  It is still useful to have a rebalance routine for performance
reasons, so we will implement one, in this section, anyway.

   There is no need to change the basic algorithm.  As before, we
convert the tree to a linear "vine", then the vine to a balanced binary
search tree.  *Note Balancing a BST::, for a review of the balancing
algorithm.

   Here is the outline and prototype for tbst_balance().

282. <TBST balance function 282> =
<*Note TBST tree-to-vine function: 284.>
<*Note TBST vine compression function: 286.>
<*Note TBST vine-to-tree function: 285.>
<*Note TBST main balance function: 283.>
   This code is included in *Note 251::.

283. <TBST main balance function 283> =
/* Balances tree. */
void
tbst_balance (struct tbst_table *tree)
{
  assert (tree != NULL);

  tree_to_vine (tree);
  vine_to_tree (tree);
}
   This code is included in *Note 282:: and *Note 408::.

* Menu:

* Transforming a TBST into a Vine::
* Transforming a Vine into a Balanced TBST::


File: libavl.info,  Node: Transforming a TBST into a Vine,  Next: Transforming a Vine into a Balanced TBST,  Prev: Balancing a TBST,  Up: Balancing a TBST

7.11.1 From Tree to Vine
------------------------

We could transform a threaded binary tree into a vine in the same way we
did for unthreaded binary trees, by use of rotations (*note
Transforming a BST into a Vine::).  But one of the reasons we did it
that way was to avoid use of a stack, which is no longer a problem.
It's now simpler to rearrange nodes by inorder traversal.

   We start by finding the minimum node in the tree as p, which will
step through the tree in inorder.  During each trip through the main
loop, we find p's successor as q and make p the left child of q.  We
also have to make sure that p's right thread points to q.  That's all
there is to it.

284. <TBST tree-to-vine function 284> =
static void
tree_to_vine (struct tbst_table *tree)
{
  struct tbst_node *p;

  if (tree->tbst_root == NULL)
    return;

  p = tree->tbst_root;
  while (p->tbst_tag[0] == TBST_CHILD)
    p = p->tbst_link[0];

  for (;;)
    {
      struct tbst_node *q = p->tbst_link[1];
      if (p->tbst_tag[1] == TBST_CHILD)
        {
          while (q->tbst_tag[0] == TBST_CHILD)
            q = q->tbst_link[0];
          p->tbst_tag[1] = TBST_THREAD;
          p->tbst_link[1] = q;
        }

      if (q == NULL)
        break;

      q->tbst_tag[0] = TBST_CHILD;
      q->tbst_link[0] = p;
      p = q;
    }

  tree->tbst_root = p;
}
   This code is included in *Note 282::.

   Sometimes one trip through the main loop above will put the TBST into
an inconsistent state, where two different nodes are the parent of a
third node.  Such an inconsistency is always corrected in the next trip
through the loop.  An example is warranted.  Suppose the original
threaded binary tree looks like this, with nodes p and q for the
initial iteration of the loop as marked:

 [image src="tbstbal1.png" text="                                          3
                              ____....---' \\
                             1,p            []
                            /   `._
                           []      2,q
                                 _'   \\
                                [1]    [3]

" ]

The first trip through the loop makes p, 1, the child of q, 2, but p's
former parent's left child pointer still points to p.  We now have a
situation where node 1 has two parents: both 2 and 3.  This diagram
tries to show the situation by omitting the line that would otherwise
lead down from 3 to 2:

 [image src="tbstbal2.png" text="                                          3
                                           \\
                                   2,q      []
                             __..-'   \\
                            1,p        [3]
                           /   \\
                          []    [2]

" ]

On the other hand, node 2's right thread still points to 3, so on the
next trip through the loop there is no trouble finding the new p's
successor.  Node 3 is made the parent of 2 and all is well.  This
diagram shows the new p and q, then the fixed-up vine.  The only
difference is that node 3 now, correctly, has 2 as its left child:

 [image src="tbstbal3.png" text="                            3,q                     3,q
                               \\              __..-'   \\
                     2,p        []           2,p        []
                 _.-'   \\          =>    _.-'   \\
                1        [3]            1        [3]
               / \\                     / \\
              []  [2]                 []  [2]

" ]


File: libavl.info,  Node: Transforming a Vine into a Balanced TBST,  Prev: Transforming a TBST into a Vine,  Up: Balancing a TBST

7.11.2 From Vine to Balanced Tree
---------------------------------

Transforming a vine into a balanced threaded BST is similar to the same
operation on an unthreaded BST.  We can use the same algorithm,
adjusting it for presence of the threads.  The following outline is
similar to <*Note BST balance function: 87.>.  In fact, we entirely
reuse <*Note Calculate leaves: 91.>, just changing bst to tbst.  We
omit the final check on the tree's height, because none of the TBST
functions are height-limited.

285. <TBST vine-to-tree function 285> =
static void
vine_to_tree (struct tbst_table *tree)
{
  unsigned long vine;   /* Number of nodes in main vine. */
  unsigned long leaves; /* Nodes in incomplete bottom level, if any. */
  int height;           /* Height of produced balanced tree. */

  <*Note Calculate leaves; bst => tbst: 91.>
  <*Note Reduce TBST vine general case to special case: 287.>
  <*Note Make special case TBST vine into balanced tree and count height: 288.>
}
   This code is included in *Note 282:: and *Note 408::.

   Not many changes are needed to adapt the algorithm to handle threads.
Consider the basic right rotation transformation used during a
compression:

 [image src="compress.png" text="                              |          |
                              R          B
                             <r>        <b>
                         _.-'   \\      /   `_
                         B       c => a       R
                        <b>                  <r>
                       /   \\                /   \\
                      a     b              b     c

" ]

The rotation does not disturb a or c, so the only node that can cause
trouble is b.  If b is a real child node, then there's no need to do
anything differently.  But if b is a thread, then we have to swap
around the direction of the thread, like this:

 [image src="tbstcmp.png" text="                               |          |
                               R          B
                              <r>        <b>
                        __..-'   \\      /   `._
                        B         c => a        R
                       <b>                     <r>
                      /   \\                  _'   \\
                     a     [R]              [B]    c

" ]

After a rotation that involves a thread, the next rotation on B will
not involve a thread.  So after we perform a rotation that adjusts a
thread in one place, the next one in the same place will not require a
thread adjustment.

   Every node in the vine we start with has a thread as its right link.
This means that during the first pass along the main vine we must
perform thread adjustments at every node, but subsequent passes along
the vine must not perform any adjustments.

   This simple idea is complicated by the initial partial compression
pass in trees that do not have exactly one fewer than a power of two
nodes.  After a partial compression pass, the nodes at the top of the
main vine no longer have right threads, but the ones farther down still
do.

   We deal with this complication by defining the compress() function so
it can handle a mixture of rotations with and without right threads.
The rotations that need thread adjustments will always be below the ones
that do not, so this function simply takes a pair of parameters, the
first specifying how many rotations without thread adjustment to
perform, the next how many with thread adjustment.  Compare this code
to that for unthreaded BSTs:

286. <TBST vine compression function 286> =
/* Performs a nonthreaded compression operation nonthread times,
   then a threaded compression operation thread times,
   starting at root. */
static void
compress (struct tbst_node *root,
          unsigned long nonthread, unsigned long thread)
{
  assert (root != NULL);

  while (nonthread-)
    {
      struct tbst_node *red = root->tbst_link[0];
      struct tbst_node *black = red->tbst_link[0];

      root->tbst_link[0] = black;
      red->tbst_link[0] = black->tbst_link[1];
      black->tbst_link[1] = red;
      root = black;
    }

  while (thread-)
    {
      struct tbst_node *red = root->tbst_link[0];
      struct tbst_node *black = red->tbst_link[0];

      root->tbst_link[0] = black;
      red->tbst_link[0] = black;
      red->tbst_tag[0] = TBST_THREAD;
      black->tbst_tag[1] = TBST_CHILD;
      root = black;
    }
}
   This code is included in *Note 282::.

   When we reduce the general case to the 2**n - 1 special case, all of
the rotations adjust threads:

287. <Reduce TBST vine general case to special case 287> =
compress ((struct tbst_node *) &tree->tbst_root, 0, leaves);
   This code is included in *Note 285::.

   We deal with the first compression specially, in order to clean up
any remaining unadjusted threads:

288. <Make special case TBST vine into balanced tree and count height 288> =
vine = tree->tbst_count - leaves;
height = 1 + (leaves > 0);
if (vine > 1)
  {
    unsigned long nonleaves = vine / 2;
    leaves /= 2;
    if (leaves > nonleaves)
      {
        leaves = nonleaves;
        nonleaves = 0;
      }
    else
      nonleaves -= leaves;

    compress ((struct tbst_node *) &tree->tbst_root, leaves, nonleaves);
    vine /= 2;
    height++;
  }
   See also *Note 289::.
This code is included in *Note 285::.

   After this, all the remaining compressions use only rotations without
thread adjustment, and we're done:

289. <Make special case TBST vine into balanced tree and count height 288> +=
while (vine > 1)
  {
    compress ((struct tbst_node *) &tree->tbst_root, vine / 2, 0);
    vine /= 2;
    height++;
  }


File: libavl.info,  Node: Testing TBSTs,  Prev: Balancing a TBST,  Up: Threaded Binary Search Trees

7.12 Testing
============

There's little new in the testing code.  We do add an test for
tbst_balance(), because none of the existing tests exercise it.  This
test doesn't check that tbst_balance() actually balances the tree, it
just verifies that afterwards the tree contains the items it should, so
to be certain that balancing is correct, turn up the verbosity and look
at the trees printed.

   Function print_tree_structure() prints thread node numbers preceded
by `>', with null threads indicated by `>>'.  This notation is
compatible with the plain text output format of the `texitree' program
used to draw the binary trees in this book.  (It will cause errors for
PostScript output because it omits node names.)

290. <tbst-test.c 290> =
<*Note License: 1.>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "tbst.h"
#include "test.h"

<*Note TBST print function: 291.>
<*Note BST traverser check function; bst => tbst: 104.>
<*Note Compare two TBSTs for structure and content: 292.>
<*Note Recursively verify TBST structure: 293.>
<*Note TBST verify function: 294.>
<*Note TBST test function: 295.>
<*Note BST overflow test function; bst => tbst: 122.>

291. <TBST print function 291> =
void
print_tree_structure (struct tbst_node *node, int level)
{
  int i;

  if (level > 16)
    {
      printf ("[...]");
      return;
    }

  if (node == NULL)
    {
      printf ("<nil>");
      return;
    }

  printf ("%d(", node->tbst_data ? *(int *) node->tbst_data : -1);

  for (i = 0; i <= 1; i++)
    {
      if (node->tbst_tag[i] == TBST_CHILD)
        {
          if (node->tbst_link[i] == node)
            printf ("loop");
          else
            print_tree_structure (node->tbst_link[i], level + 1);
        }
      else if (node->tbst_link[i] != NULL)
        printf (">%d",
                (node->tbst_link[i]->tbst_data
                ? *(int *) node->tbst_link[i]->tbst_data : -1));
      else
        printf (">>");

      if (i == 0)
        fputs (", ", stdout);
    }

  putchar (')');
}

void
print_whole_tree (const struct tbst_table *tree, const char *title)
{
  printf ("%s: ", title);
  print_tree_structure (tree->tbst_root, 0);
  putchar ('\n');
}
   This code is included in *Note 290::, *Note 330::, and *Note 368::.

292. <Compare two TBSTs for structure and content 292> =
static int
compare_trees (struct tbst_node *a, struct tbst_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      if (a != NULL || b != NULL)
        {
          printf (" a=%d b=%d\n",
                  a ? *(int *) a->tbst_data : -1,
                  b ? *(int *) b->tbst_data : -1);
          assert (0);
        }
      return 1;
    }
  assert (a != b);

  if (*(int *) a->tbst_data != *(int *) b->tbst_data
      || a->tbst_tag[0] != b->tbst_tag[0]
      || a->tbst_tag[1] != b->tbst_tag[1])
    {
      printf (" Copied nodes differ: a=%d b=%d a:",
              *(int *) a->tbst_data, *(int *) b->tbst_data);

      if (a->tbst_tag[0] == TBST_CHILD)
        printf ("l");
      if (a->tbst_tag[1] == TBST_CHILD)
        printf ("r");

      printf (" b:");
      if (b->tbst_tag[0] == TBST_CHILD)
        printf ("l");
      if (b->tbst_tag[1] == TBST_CHILD)
        printf ("r");

      printf ("\n");
      return 0;
    }

  if (a->tbst_tag[0] == TBST_THREAD)
    assert ((a->tbst_link[0] == NULL) != (a->tbst_link[0] != b->tbst_link[0]));
  if (a->tbst_tag[1] == TBST_THREAD)
    assert ((a->tbst_link[1] == NULL) != (a->tbst_link[1] != b->tbst_link[1]));

  okay = 1;
  if (a->tbst_tag[0] == TBST_CHILD)
    okay &= compare_trees (a->tbst_link[0], b->tbst_link[0]);
  if (a->tbst_tag[1] == TBST_CHILD)
    okay &= compare_trees (a->tbst_link[1], b->tbst_link[1]);
  return okay;
}
   This code is included in *Note 290::.

293. <Recursively verify TBST structure 293> =
static void
recurse_verify_tree (struct tbst_node *node, int *okay, size_t *count,
                     int min, int max)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */

  if (node == NULL)
    {
      *count = 0;
      return;
    }
  d = *(int *) node->tbst_data;

  <*Note Verify binary search tree ordering: 114.>

  subcount[0] = subcount[1] = 0;
  if (node->tbst_tag[0] == TBST_CHILD)
    recurse_verify_tree (node->tbst_link[0], okay, &subcount[0], min, d - 1);
  if (node->tbst_tag[1] == TBST_CHILD)
    recurse_verify_tree (node->tbst_link[1], okay, &subcount[1], d + 1, max);
  *count = 1 + subcount[0] + subcount[1];
}
   This code is included in *Note 290::.

294. <TBST verify function 294> =
static int
verify_tree (struct tbst_table *tree, int array[], size_t n)
{
  int okay = 1;

  <*Note Check tree->bst_count is correct; bst => tbst: 110.>

  if (okay)
    {
      <*Note Check BST structure; bst => tbst: 111.>
    }

  if (okay)
    {
      <*Note Check that the tree contains all the elements it should; bst => tbst: 115.>
    }

  if (okay)
    {
      <*Note Check that forward traversal works; bst => tbst: 116.>
    }

  if (okay)
    {
      <*Note Check that backward traversal works; bst => tbst: 117.>
    }

  if (okay)
    {
      <*Note Check that traversal from the null element works; bst => tbst: 118.>
    }

  return okay;
}
   This code is included in *Note 290::.

295. <TBST test function 295> =
int
test_correctness (struct libavl_allocator *allocator,
                 int insert[], int delete[], int n, int verbosity)
{
  struct tbst_table *tree;
  int okay = 1;
  int i;

  <*Note Test creating a BST and inserting into it; bst => tbst: 102.>
  <*Note Test BST traversal during modifications; bst => tbst: 103.>
  <*Note Test deleting nodes from the BST and making copies of it; bst => tbst: 105.>
  <*Note Test destroying the tree; bst => tbst: 108.>

  <*Note Test TBST balancing: 296.>

  return okay;
}
   This code is included in *Note 290::, *Note 411::, and *Note 515::.

296. <Test TBST balancing 296> =
/* Test tbst_balance(). */
if (verbosity >= 2)
  printf ("  Testing balancing...\n");

tree = tbst_create (compare_ints, NULL, allocator);
if (tree == NULL)
  {
    if (verbosity >= 0)
      printf ("  Out of memory creating tree.\n");
    return 1;
  }

for (i = 0; i < n; i++)
  {
    void **p = tbst_probe (tree, &insert[i]);
    if (p == NULL)
      {
        if (verbosity >= 0)
          printf ("    Out of memory in insertion.\n");
        tbst_destroy (tree, NULL);
        return 1;
      }
    if (*p != &insert[i])
      printf ("    Duplicate item in tree!\n");
  }

if (verbosity >= 4)
  print_whole_tree (tree, "    Prebalance");
tbst_balance (tree);
if (verbosity >= 4)
  print_whole_tree (tree, "    Postbalance");

if (!verify_tree (tree, insert, n))
  return 0;

tbst_destroy (tree, NULL);
   This code is included in *Note 295::.


File: libavl.info,  Node: Threaded AVL Trees,  Next: Threaded Red-Black Trees,  Prev: Threaded Binary Search Trees,  Up: Top

8 Threaded AVL Trees
********************

The previous chapter introduced a new concept in BSTs, the idea of
threads.  Threads allowed us to simplify traversals and eliminate the
use of stacks.  On the other hand, threaded trees can still grow tall
enough that they reduce the program's performance unacceptably, the
problem that balanced trees were meant to solve.  Ideally, we'd like to
add threads to balanced trees, to produce threaded balanced trees that
combine the best of both worlds.

   We can do this, and it's not even very difficult.  This chapter will
show how to add threads to AVL trees.  The next will show how to add
them to red-black trees.

   Here's an outline of the table implementation for threaded AVL or
"TAVL" trees that we'll develop in this chapter.  Note the usage of
prefix tavl_ for these functions.

297. <tavl.h 297> =
<*Note License: 1.>
#ifndef TAVL_H
#define TAVL_H 1

#include <stddef.h>

<*Note Table types; tbl => tavl: 14.>
<*Note BST maximum height; bst => tavl: 28.>
<*Note TBST table structure; tbst => tavl: 250.>
<*Note TAVL node structure: 299.>
<*Note TBST traverser structure; tbst => tavl: 267.>
<*Note Table function prototypes; tbl => tavl: 15.>

#endif /* tavl.h */

298. <tavl.c 298> =
<*Note License: 1.>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "tavl.h"

<*Note TAVL functions: 300.>

* Menu:

* TAVL Data Types::
* TBST Rotations::
* TAVL Operations::
* Inserting into a TAVL Tree::
* Deleting from a TAVL Tree::
* Copying a TAVL Tree::
* Testing TAVL Trees::


File: libavl.info,  Node: TAVL Data Types,  Next: TBST Rotations,  Prev: Threaded AVL Trees,  Up: Threaded AVL Trees

8.1 Data Types
==============

The TAVL node structure takes the basic fields for a BST and adds a
balance factor for AVL balancing and a pair of tag fields to allow for
threading.

299. <TAVL node structure 299> =
/* Characterizes a link as a child pointer or a thread. */
enum tavl_tag
  {
    TAVL_CHILD,                     /* Child pointer. */
    TAVL_THREAD                     /* Thread. */
  };

/* An TAVL tree node. */
struct tavl_node
  {
    struct tavl_node *tavl_link[2]; /* Subtrees. */
    void *tavl_data;                /* Pointer to data. */
    unsigned char tavl_tag[2];      /* Tag fields. */
    signed char tavl_balance;       /* Balance factor. */
  };
   This code is included in *Note 297::.

Exercises:

1. struct avl_node contains three pointer members and a single
character member, whereas struct tavl_node additionally contains an
array of two characters.  Is struct tavl_node necessarily larger than
struct avl_node?  [*Note answer: 8-1#1..]


File: libavl.info,  Node: TBST Rotations,  Next: TAVL Operations,  Prev: TAVL Data Types,  Up: Threaded AVL Trees

8.2 Rotations
=============

Rotations are just as useful in threaded BSTs as they are in unthreaded
ones.  We do need to re-examine the idea, though, to see how the
presence of threads affect rotations.

   A generic rotation looks like this diagram taken from *Note BST
Rotations:::

 [image src="rotation.png" text="                               |        |
                               Y        X
                              / \\      / \\
                             X   c    a   Y
                             ^            ^
                            a b          b c

" ]

Any of the subtrees labeled a, b, and c may be in fact threads.  In the
most extreme case, all of them are threads, and the rotation looks like
this:

 [image src="tavlrot.png" text="                               Y         X
                           _.-' \\       / `._
                          X      []    []    Y
                         / \\               _' \\
                        []  [Y]           [X]  []

" ]

As you can see, the thread from X to Y, represented by subtree b,
reverses direction and becomes a thread from Y to X following a right
rotation.  This has to be handled as a special case in code for
rotation.  See Exercise 1 for details.

   On the other hand, there is no need to do anything special with
threads originating in subtrees of a rotated node.  This is a direct
consequence of the locality and order-preserving properties of a
rotation (*note BST Rotations::).  Here's an example diagram to
demonstrate.  Note in particular that the threads from A, B, and C
point to the same nodes in both trees:

 [image src="tavlrot2.png" text="                          Y                  X
                  ___..--' `._           _.-' `--..___
                 X            C         A             Y
             _.-' `._       _' \\       / \\        _.-' `._
            A        B     [Y]  []    []  [X]    B        C
           / \\     _' \\                        _' \\     _' \\
          []  [X] [X]  [Y]                    [X]  [Y] [Y]  []

" ]

Exercises:

1. Write functions for right and left rotations in threaded BSTs,
analogous to those for unthreaded BSTs developed in Exercise 4.3-2.
[*Note answer: 8-2#1..]


File: libavl.info,  Node: TAVL Operations,  Next: Inserting into a TAVL Tree,  Prev: TBST Rotations,  Up: Threaded AVL Trees

8.3 Operations
==============

Now we'll implement all the usual operations for TAVL trees.  We can
reuse everything from TBSTs except insertion, deletion, and copy
functions.  Most of the copy function code will in fact be reused also.
Here's the outline:

300. <TAVL functions 300> =
<*Note TBST creation function; tbst => tavl: 252.>
<*Note TBST search function; tbst => tavl: 253.>
<*Note TAVL item insertion function: 301.>
<*Note Table insertion convenience functions; tbl => tavl: 592.>
<*Note TAVL item deletion function: 311.>
<*Note TBST traversal functions; tbst => tavl: 268.>
<*Note TAVL copy function: 329.>
<*Note TBST destruction function; tbst => tavl: 281.>
<*Note Default memory allocation functions; tbl => tavl: 6.>
<*Note Table assertion functions; tbl => tavl: 594.>
   This code is included in *Note 298::.


File: libavl.info,  Node: Inserting into a TAVL Tree,  Next: Deleting from a TAVL Tree,  Prev: TAVL Operations,  Up: Threaded AVL Trees

8.4 Insertion
=============

Insertion into an AVL tree is not complicated much by the need to update
threads.  The outline is the same as before, and the code for step 3
and the local variable declarations can be reused entirely:

301. <TAVL item insertion function 301> =
void **
tavl_probe (struct tavl_table *tree, void *item)
{
  <*Note avl_probe() local variables; avl => tavl: 147.>

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search TAVL tree for insertion point: 302.>
  <*Note Step 2: Insert TAVL node: 303.>
  <*Note Step 3: Update balance factors after AVL insertion; avl => tavl: 150.>
  <*Note Step 4: Rebalance after TAVL insertion: 304.>
}
   This code is included in *Note 300::.

* Menu:

* Steps 1 and 2 in TAVL Insertion::
* Rebalancing TAVL Trees::
* TAVL Insertion Symmetric Case::


File: libavl.info,  Node: Steps 1 and 2 in TAVL Insertion,  Next: Rebalancing TAVL Trees,  Prev: Inserting into a TAVL Tree,  Up: Inserting into a TAVL Tree

8.4.1 Steps 1 and 2: Search and Insert
--------------------------------------

The first step is a lot like the unthreaded AVL version in <*Note Step
1: Search AVL tree for insertion point: 148.>.  There is an unfortunate
special case for an empty tree, because a null pointer for tavl_root
indicates an empty tree but in a nonempty tree we must seek a thread
link.  After we're done, p, not q as before, is the node below which a
new node should be inserted, because the test for stepping outside the
binary tree now comes before advancing p.

302. <Step 1: Search TAVL tree for insertion point 302> =
z = (struct tavl_node *) &tree->tavl_root;
y = tree->tavl_root;
if (y != NULL)
  {
    for (q = z, p = y; ; q = p, p = p->tavl_link[dir])
      {
        int cmp = tree->tavl_compare (item, p->tavl_data, tree->tavl_param);
        if (cmp == 0)
          return &p->tavl_data;

        if (p->tavl_balance != 0)
          z = q, y = p, k = 0;
        da[k++] = dir = cmp > 0;

        if (p->tavl_tag[dir] == TAVL_THREAD)
          break;
      }
  }
else
  {
    p = z;
    dir = 0;
  }
   This code is included in *Note 301::.

   The insertion adds to the TBST code by setting the balance factor of
the new node and handling the first insertion into an empty tree as a
special case:

303. <Step 2: Insert TAVL node 303> =
<*Note Step 2: Insert TBST node; tbst => tavl: 256.>
n->tavl_balance = 0;
if (tree->tavl_root == n)
  return &n->tavl_data;
   This code is included in *Note 301::.


File: libavl.info,  Node: Rebalancing TAVL Trees,  Next: TAVL Insertion Symmetric Case,  Prev: Steps 1 and 2 in TAVL Insertion,  Up: Inserting into a TAVL Tree

8.4.2 Step 4: Rebalance
-----------------------

Now we're finally to the interesting part, the rebalancing step.  We
can tell whether rebalancing is necessary based on the balance factor
of y, the same as in unthreaded AVL insertion:

304. <Step 4: Rebalance after TAVL insertion 304> =
if (y->tavl_balance == -2)
  {
    <*Note Rebalance TAVL tree after insertion in left subtree: 305.>
  }
else if (y->tavl_balance == +2)
  {
    <*Note Rebalance TAVL tree after insertion in right subtree: 308.>
  }
else
  return &n->tavl_data;
z->tavl_link[y != z->tavl_link[0]] = w;

return &n->tavl_data;
   This code is included in *Note 301::.

   We will examine the case of insertion in the left subtree of y, the
node at which we must rebalance.  We take x as y's child on the side of
the new node, then, as for unthreaded AVL insertion, we distinguish two
cases based on the balance factor of x:

305. <Rebalance TAVL tree after insertion in left subtree 305> =
struct tavl_node *x = y->tavl_link[0];
if (x->tavl_balance == -1)
  {
    <*Note Rebalance for - balance factor in TAVL insertion in left subtree: 306.>
  }
else
  {
    <*Note Rebalance for + balance factor in TAVL insertion in left subtree: 307.>
  }
   This code is included in *Note 304::.

Case 1: x has - balance factor
..............................

As for unthreaded insertion, we rotate right at y (*note Rebalancing
AVL Trees::).  Notice the resemblance of the following code to
rotate_right() in the solution to Exercise 8.2-1.

306. <Rebalance for - balance factor in TAVL insertion in left subtree 306> =
w = x;
if (x->tavl_tag[1] == TAVL_THREAD)
  {
    x->tavl_tag[1] = TAVL_CHILD;
    y->tavl_tag[0] = TAVL_THREAD;
    y->tavl_link[0] = x;
  }
else
  y->tavl_link[0] = x->tavl_link[1];
x->tavl_link[1] = y;
x->tavl_balance = y->tavl_balance = 0;
   This code is included in *Note 305::.

Case 2: x has + balance factor
..............................

When x has a + balance factor, we perform the transformation shown
below, which consists of a left rotation at x followed by a right
rotation at y.  This is the same transformation used in unthreaded
insertion:

 [image src="tavlins1.png" text="                                 |
                                 y           |
                               <-->          w
                          __.-'    \\        <0>
                          x         d      /   \\
                         <+>          =>  x     y
                        /   \\             ^     ^
                       a     w           a b   c d
                             ^
                            b c

" ]

We could simply apply the standard code from Exercise 8.2-1 in each
rotation (see Exercise 1), but it is just as straightforward to do both
of the rotations together, then clean up any threads.  Subtrees a and d
cannot cause thread-related trouble, because they are not disturbed
during the transformation: a remains x's left child and d remains y's
right child.  The children of w, subtrees b and c, do require handling.
If subtree b is a thread, then after the rotation and before fix-up
x's right link points to itself, and, similarly, if c is a thread then
y's left link points to itself.  These links must be changed into
threads to w instead, and w's links must be tagged as child pointers.

   If both b and c are threads then the transformation looks like the
diagram below, showing pre-rebalancing and post-rebalancing,
post-fix-up views.  The AVL balance rule implies that if b and c are
threads then a and d are also:

 [image src="tavlins2.png" text="                               |
                               y                |
                             <-->               w
                   ___...---'    \\             <0>
                   x              []       _.-'   `._
                  <+>                =>   x          y
                 /   `._                 / \\       _' \\
                []      w               []  [w]   [w]  []
                      _' \\
                     [x]  [y]

" ]

The required code is heavily based on the corresponding code for
unthreaded AVL rebalancing:

307. <Rebalance for + balance factor in TAVL insertion in left subtree 307> =
<*Note Rotate left at x then right at y in AVL tree; avl => tavl: 156.>
if (w->tavl_tag[0] == TAVL_THREAD)
  {
    x->tavl_tag[1] = TAVL_THREAD;
    x->tavl_link[1] = w;
    w->tavl_tag[0] = TAVL_CHILD;
  }
if (w->tavl_tag[1] == TAVL_THREAD)
  {
    y->tavl_tag[0] = TAVL_THREAD;
    y->tavl_link[0] = w;
    w->tavl_tag[1] = TAVL_CHILD;
  }
   This code is included in *Note 305::, *Note 324::, and *Note 667::.

Exercises:

1. Rewrite <*Note Rebalance for + balance factor in TAVL insertion in
left subtree: 307.> in terms of the routines from Exercise 8.2-1.
[*Note answer: 8-4-2#1..]


File: libavl.info,  Node: TAVL Insertion Symmetric Case,  Prev: Rebalancing TAVL Trees,  Up: Inserting into a TAVL Tree

8.4.3 Symmetric Case
--------------------

Here is the corresponding code for the case where insertion occurs in
the right subtree of y.

308. <Rebalance TAVL tree after insertion in right subtree 308> =
struct tavl_node *x = y->tavl_link[1];
if (x->tavl_balance == +1)
  {
    <*Note Rebalance for + balance factor in TAVL insertion in right subtree: 309.>
  }
else
  {
    <*Note Rebalance for - balance factor in TAVL insertion in right subtree: 310.>
  }
   This code is included in *Note 304::.

309. <Rebalance for + balance factor in TAVL insertion in right subtree 309> =
w = x;
if (x->tavl_tag[0] == TAVL_THREAD)
  {
    x->tavl_tag[0] = TAVL_CHILD;
    y->tavl_tag[1] = TAVL_THREAD;
    y->tavl_link[1] = x;
  }
else
  y->tavl_link[1] = x->tavl_link[0];
x->tavl_link[0] = y;
x->tavl_balance = y->tavl_balance = 0;
   This code is included in *Note 308::.

310. <Rebalance for - balance factor in TAVL insertion in right subtree 310> =
<*Note Rotate right at x then left at y in AVL tree; avl => tavl: 159.>
if (w->tavl_tag[0] == TAVL_THREAD)
  {
    y->tavl_tag[1] = TAVL_THREAD;
    y->tavl_link[1] = w;
    w->tavl_tag[0] = TAVL_CHILD;
  }
if (w->tavl_tag[1] == TAVL_THREAD)
  {
    x->tavl_tag[0] = TAVL_THREAD;
    x->tavl_link[0] = w;
    w->tavl_tag[1] = TAVL_CHILD;
  }
   This code is included in *Note 308::, *Note 320::, and *Note 666::.


File: libavl.info,  Node: Deleting from a TAVL Tree,  Next: Copying a TAVL Tree,  Prev: Inserting into a TAVL Tree,  Up: Threaded AVL Trees

8.5 Deletion
============

Deletion from a TAVL tree can be accomplished by combining our
knowledge about AVL trees and threaded trees.  From one perspective, we
add rebalancing to TBST deletion.  From the other perspective, we add
thread handling to AVL tree deletion.

   The function outline is about the same as usual.  We do add a helper
function for finding the parent of a TAVL node:

311. <TAVL item deletion function 311> =
<*Note Find parent of a TBST node; tbst => tavl: 327.>

void *
tavl_delete (struct tavl_table *tree, const void *item)
{
  struct tavl_node *p; /* Traverses tree to find node to delete. */
  struct tavl_node *q; /* Parent of p. */
  int dir;             /* Index into q->tavl_link[] to get p. */
  int cmp;             /* Result of comparison between item and p. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search TAVL tree for item to delete: 312.>
  <*Note Step 2: Delete item from TAVL tree: 313.>
  <*Note Steps 3 and 4: Update balance factors and rebalance after TAVL deletion: 318.>
}
   This code is included in *Note 300::.

* Menu:

* Deleting a TAVL Node Step 1 - Search::
* Deleting a TAVL Node Step 2 - Delete::
* Deleting a TAVL Node Step 3 - Update::
* Deleting a TAVL Node Step 4 - Rebalance::
* TAVL Deletion Symmetric Case::
* Finding the Parent of a TBST Node::


File: libavl.info,  Node: Deleting a TAVL Node Step 1 - Search,  Next: Deleting a TAVL Node Step 2 - Delete,  Prev: Deleting from a TAVL Tree,  Up: Deleting from a TAVL Tree

8.5.1 Step 1: Search
--------------------

We use p to search down the tree and keep track of p's parent with q.
We keep the invariant at the beginning of the loop here that
q->tavl_link[dir] == p.  As the final step, we record the item deleted
and update the tree's item count.

312. <Step 1: Search TAVL tree for item to delete 312> =
if (tree->tavl_root == NULL)
  return NULL;

q = (struct tavl_node *) &tree->tavl_root;
p = tree->tavl_root;
dir = 0;
for (;;)
  {
    cmp = tree->tavl_compare (item, p->tavl_data, tree->tavl_param);
    if (cmp == 0)
      break;
    dir = cmp > 0;

    q = p;
    if (p->tavl_tag[dir] == TAVL_THREAD)
      return NULL;
    p = p->tavl_link[dir];
  }
item = p->tavl_data;
   This code is included in *Note 311:: and *Note 670::.


File: libavl.info,  Node: Deleting a TAVL Node Step 2 - Delete,  Next: Deleting a TAVL Node Step 3 - Update,  Prev: Deleting a TAVL Node Step 1 - Search,  Up: Deleting from a TAVL Tree

8.5.2 Step 2: Delete
--------------------

The cases for deletion are the same as for a TBST (*note Deleting from
a TBST::).  The difference is that we have to copy around balance
factors and keep track of where balancing needs to start.  After the
deletion, q is the node at which balance factors must be updated and
possible rebalancing occurs and dir is the side of q from which the
node was deleted.  For cases 1 and 2, q need not change from its
current value as the parent of the deleted node.  For cases 3 and 4, q
will need to be changed.

313. <Step 2: Delete item from TAVL tree 313> =
if (p->tavl_tag[1] == TAVL_THREAD)
  {
    if (p->tavl_tag[0] == TAVL_CHILD)
      {
        <*Note Case 1 in TAVL deletion: 314.>
      }
    else
      {
        <*Note Case 2 in TAVL deletion: 315.>
      }
  }
else
  {
    struct tavl_node *r = p->tavl_link[1];
    if (r->tavl_tag[0] == TAVL_THREAD)
      {
        <*Note Case 3 in TAVL deletion: 316.>
      }
    else
      {
        <*Note Case 4 in TAVL deletion: 317.>
      }
  }

tree->tavl_alloc->libavl_free (tree->tavl_alloc, p);
   This code is included in *Note 311::.

Case 1: p has a right thread and a left child
.............................................

If p has a right thread and a left child, then we replace it by its
left child.  Rebalancing must begin right above p, which is already set
as q.  There's no need to change the TBST code:

314. <Case 1 in TAVL deletion 314> =
<*Note Case 1 in TBST deletion; tbst => tavl: 260.>
   This code is included in *Note 313::.

Case 2: p has a right thread and a left thread
..............................................

If p is a leaf, then we change q's pointer to p into a thread.  Again,
rebalancing must begin at the node that's already set up as q and
there's no need to change the TBST code:

315. <Case 2 in TAVL deletion 315> =
<*Note Case 2 in TBST deletion; tbst => tavl: 261.>
   This code is included in *Note 313::.

Case 3: p's right child has a left thread
.........................................

If p has a right child r, which in turn has no left child, then we move
r in place of p.  In this case r, having replaced p, acquires p's
former balance factor and rebalancing must start from there.  The
deletion in this case is always on the right side of the node.

316. <Case 3 in TAVL deletion 316> =
<*Note Case 3 in TBST deletion; tbst => tavl: 262.>
r->tavl_balance = p->tavl_balance;
q = r;
dir = 1;
   This code is included in *Note 313::.

Case 4: p's right child has a left child
........................................

The most general case comes up when p's right child has a left child,
where we replace p by its successor s.  In that case s acquires p's
former balance factor and rebalancing begins from s's parent r.  Node s
is always the left child of r.

317. <Case 4 in TAVL deletion 317> =
<*Note Case 4 in TBST deletion; tbst => tavl: 263.>
s->tavl_balance = p->tavl_balance;
q = r;
dir = 0;
   This code is included in *Note 313::.

Exercises:

1. Rewrite <*Note Case 4 in TAVL deletion: 317.> to replace the deleted
node's tavl_data by its successor, then delete the successor, instead of
shuffling pointers.  (Refer back to Exercise 4.8-3 for an explanation
of why this approach cannot be used in libavl.)  [*Note answer:
8-5-2#1..]


File: libavl.info,  Node: Deleting a TAVL Node Step 3 - Update,  Next: Deleting a TAVL Node Step 4 - Rebalance,  Prev: Deleting a TAVL Node Step 2 - Delete,  Up: Deleting from a TAVL Tree

8.5.3 Step 3: Update Balance Factors
------------------------------------

Rebalancing begins from node q, from whose side dir a node was deleted.
Node q at the beginning of the iteration becomes node y, the root of
the balance factor update and rebalancing, and dir at the beginning of
the iteration is used to separate the left-side and right-side deletion
cases.

   The loop also updates the values of q and dir for rebalancing and
for use in the next iteration of the loop, if any.  These new values can
only be assigned after the old ones are no longer needed, but must be
assigned before any rebalancing so that the parent link to y can be
changed.  For q this is after y receives q's old value and before
rebalancing.  For dir, it is after the branch point that separates the
left-side and right-side deletion cases, so the dir assignment is
duplicated in each branch.  The code used to update q is discussed
later.

318. <Steps 3 and 4: Update balance factors and rebalance after TAVL deletion 318> =
while (q != (struct tavl_node *) &tree->tavl_root)
  {
    struct tavl_node *y = q;

    q = find_parent (tree, y);

    if (dir == 0)
      {
        dir = q->tavl_link[0] != y;
        y->tavl_balance++;
        if (y->tavl_balance == +1)
          break;
        else if (y->tavl_balance == +2)
          {
            <*Note Step 4: Rebalance after TAVL deletion: 319.>
          }
      }
    else
      {
        <*Note Steps 3 and 4: Symmetric case in TAVL deletion: 323.>
      }
  }

tree->tavl_count-;
return (void *) item;
   This code is included in *Note 311::.


File: libavl.info,  Node: Deleting a TAVL Node Step 4 - Rebalance,  Next: TAVL Deletion Symmetric Case,  Prev: Deleting a TAVL Node Step 3 - Update,  Up: Deleting from a TAVL Tree

8.5.4 Step 4: Rebalance
-----------------------

Rebalancing after deletion in a TAVL tree divides into three cases.  The
first of these is analogous to case 1 in unthreaded AVL deletion, the
other two to case 2 (*note Inserting into a TBST::).  The cases are
distinguished, as usual, based on the balance factor of right child x
of the node y at which rebalancing occurs:

319. <Step 4: Rebalance after TAVL deletion 319> =
struct tavl_node *x = y->tavl_link[1];

assert (x != NULL);
if (x->tavl_balance == -1)
  {
    <*Note Rebalance for - balance factor after TAVL deletion in left subtree: 320.>
  }
else
  {
    q->tavl_link[dir] = x;

    if (x->tavl_balance == 0)
      {
        <*Note Rebalance for 0 balance factor after TAVL deletion in left subtree: 321.>
        break;
      }
    else /* x->tavl_balance == +1 */
      {
        <*Note Rebalance for + balance factor after TAVL deletion in left subtree: 322.>
      }
  }
   This code is included in *Note 318::.

Case 1: x has - balance factor
..............................

This case is just like case 2 in TAVL insertion.  In fact, we can even
reuse the code:

320. <Rebalance for - balance factor after TAVL deletion in left subtree 320> =
struct tavl_node *w;

<*Note Rebalance for - balance factor in TAVL insertion in right subtree: 310.>
q->tavl_link[dir] = w;
   This code is included in *Note 319::.

Case 2: x has 0 balance factor
..............................

If x has a 0 balance factor, then we perform a left rotation at y.  The
transformation looks like this, with subtree heights listed under their
labels:

 [image src="tavldel.png" text="                          |                     |
                          s                     r
                        <++>                   <->
                      _'    `_             _.-'   \\
                      a        r    =>     s       c
                     h-1      <0>         <+>      h
                             /   \\      _'   \\
                            b     c     a     b
                            h     h    h-1    h

" ]

Subtree b is taller than subtree a, so even if h takes its minimum
value of 1, then subtree b has height h == 1 and, therefore, it must
contain at least one node and there is no need to do any checking for
threads.  The code is simple:

321. <Rebalance for 0 balance factor after TAVL deletion in left subtree 321> =
y->tavl_link[1] = x->tavl_link[0];
x->tavl_link[0] = y;
x->tavl_balance = -1;
y->tavl_balance = +1;
   This code is included in *Note 319:: and *Note 443::.

Case 3: x has + balance factor
..............................

If x has a + balance factor, we perform a left rotation at y, same as
for case 2, and the transformation looks like this:

 [image src="tavldel2.png" text="                        |                        |
                        s                        s
                      <++>                      <0>
                    _'    `._             __..-'   \\
                    a         r    =>     r         c
                   h-1       <+>         <0>        h
                           _'   \\      _'   \\
                           b     c     a      b
                          h-1    h    h-1    h-1

" ]

One difference from case 2 is in the resulting balance factors.  The
other is that if h == 1, then subtrees a and b have height h - 1 == 0,
so a and b may actually be threads.  In that case, the transformation
must be done this way:

 [image src="tavldel3.png" text="                 |
                 s                              |
               <++>                             r
              /    `._                         <0>
             []        r                 __..-'   `._
                      <+>          =>    s            c
                    _'   `._            <0>          <0>
                   [s]       c         /   \\       _'   \\
                            <0>       []    [r]   [r]    []
                          _'   \\
                         [r]    []

" ]

This code handles both possibilities:

322. <Rebalance for + balance factor after TAVL deletion in left subtree 322> =
if (x->tavl_tag[0] == TAVL_CHILD)
  y->tavl_link[1] = x->tavl_link[0];
else
  {
    y->tavl_tag[1] = TAVL_THREAD;
    x->tavl_tag[0] = TAVL_CHILD;
  }
x->tavl_link[0] = y;
y->tavl_balance = x->tavl_balance = 0;
   This code is included in *Note 319::.


File: libavl.info,  Node: TAVL Deletion Symmetric Case,  Next: Finding the Parent of a TBST Node,  Prev: Deleting a TAVL Node Step 4 - Rebalance,  Up: Deleting from a TAVL Tree

8.5.5 Symmetric Case
--------------------

Here's the code for the symmetric case.

323. <Steps 3 and 4: Symmetric case in TAVL deletion 323> =
dir = q->tavl_link[0] != y;
y->tavl_balance-;
if (y->tavl_balance == -1)
  break;
else if (y->tavl_balance == -2)
  {
    struct tavl_node *x = y->tavl_link[0];
    assert (x != NULL);
    if (x->tavl_balance == +1)
      {
        <*Note Rebalance for + balance factor after TAVL deletion in right subtree: 324.>
      }
    else
      {
        q->tavl_link[dir] = x;

        if (x->tavl_balance == 0)
          {
            <*Note Rebalance for 0 balance factor after TAVL deletion in right subtree: 325.>
            break;
          }
        else /* x->tavl_balance == -1 */
          {
            <*Note Rebalance for - balance factor after TAVL deletion in right subtree: 326.>
          }
      }
  }
   This code is included in *Note 318::.

324. <Rebalance for + balance factor after TAVL deletion in right subtree 324> =
struct tavl_node *w;

<*Note Rebalance for + balance factor in TAVL insertion in left subtree: 307.>
q->tavl_link[dir] = w;
   This code is included in *Note 323::.

325. <Rebalance for 0 balance factor after TAVL deletion in right subtree 325> =
y->tavl_link[0] = x->tavl_link[1];
x->tavl_link[1] = y;
x->tavl_balance = +1;
y->tavl_balance = -1;
   This code is included in *Note 323:: and *Note 444::.

326. <Rebalance for - balance factor after TAVL deletion in right subtree 326> =
if (x->tavl_tag[1] == TAVL_CHILD)
  y->tavl_link[0] = x->tavl_link[1];
else
  {
    y->tavl_tag[0] = TAVL_THREAD;
    x->tavl_tag[1] = TAVL_CHILD;
  }
x->tavl_link[1] = y;
y->tavl_balance = x->tavl_balance = 0;
   This code is included in *Note 323::.


File: libavl.info,  Node: Finding the Parent of a TBST Node,  Prev: TAVL Deletion Symmetric Case,  Up: Deleting from a TAVL Tree

8.5.6 Finding the Parent of a Node
----------------------------------

The last component of tavl_delete() left undiscussed is the
implementation of its helper function find_parent(), which requires an
algorithm for finding the parent of an arbitrary node in a TAVL tree.
If there were no efficient algorithm for this purpose, we would have to
keep a stack of parent nodes as we did for unthreaded AVL trees.  (This
is still an option, as shown in Exercise 3.)  We are fortunate that
such an algorithm does exist.  Let's discover it.

   Because child pointers always lead downward in a BST, the only way
that we're going to get from one node to another one above it is by
following a thread.  Almost directly from our definition of threads, we
know that if a node q has a right child p, then there is a left thread
in the subtree rooted at p that points back to q.  Because a left
thread points from a node to its predecessor, this left thread to q
must come from q's successor, which we'll call s.  The situation looks
like this:

 [image src="tbstparent.png" text="                               q
                              / `--...___
                             a           p
                                       _' \\
                                      ...  b
                                    _'
                                   s
                                 _' \\
                                [q]  c

" ]

This leads immediately to an algorithm to find q given p, if p is q's
right child.  We simply follow left links starting at p until we we
reach a thread, then we follow that thread.  On the other hand, it
doesn't help if p is q's left child, but there's an analogous situation
with q's predecessor in that case.

   Will this algorithm work for any node in a TBST?  It won't work for
the root node, because no thread points above the root (see
Exercise 2).  It will work for any other node, because any node other
than the root has its successor or predecessor as its parent.

   Here is the actual code, which finds and returns the parent of node.
It traverses both the left and right subtrees of node at once, using x
to move down to the left and y to move down to the right.  When it hits
a thread on one side, it checks whether it leads to node's parent.  If
it does, then we're done.  If it doesn't, then we continue traversing
along the other side, which is guaranteed to lead to node's parent.

327. <Find parent of a TBST node 327> =
/* Returns the parent of node within tree,
   or a pointer to tbst_root if s is the root of the tree. */
static struct tbst_node *
find_parent (struct tbst_table *tree, struct tbst_node *node)
{
  if (node != tree->tbst_root)
    {
      struct tbst_node *x, *y;

      for (x = y = node; ; x = x->tbst_link[0], y = y->tbst_link[1])
        if (y->tbst_tag[1] == TBST_THREAD)
          {
            struct tbst_node *p = y->tbst_link[1];
            if (p == NULL || p->tbst_link[0] != node)
              {
                while (x->tbst_tag[0] == TBST_CHILD)
                  x = x->tbst_link[0];
                p = x->tbst_link[0];
              }
            return p;
          }
        else if (x->tbst_tag[0] == TBST_THREAD)
          {
            struct tbst_node *p = x->tbst_link[0];
            if (p == NULL || p->tbst_link[1] != node)
              {
                while (y->tbst_tag[1] == TBST_CHILD)
                  y = y->tbst_link[1];
                p = y->tbst_link[1];
              }
            return p;
          }
    }
  else
    return (struct tbst_node *) &tree->tbst_root;
}
   This code is included in *Note 311::, *Note 668::, and *Note 670::.

See also:  *Note Knuth 1997::, exercise 2.3.1-19.

Exercises:

*1. Show that finding the parent of a given node using this algorithm,
averaged over all the node within a TBST, requires only a constant
number of links to be followed.  [*Note answer: 8-5-6#1..]

2. The structure of threads in our TBSTs force finding the parent of the
root node to be special-cased.  Suggest a modification to the tree
structure to avoid this.  [*Note answer: 8-5-6#2..]

3. It can take several steps to find the parent of an arbitrary node in
a TBST, even though the operation is "efficient" in the sense of
Exercise 7.7-4.  On the other hand, finding the parent of a node is
very fast with a stack, but it costs time to construct the stack.
Rewrite tavl_delete() to use a stack instead of the parent node
algorithm.  [*Note answer: 8-5-6#3..]


File: libavl.info,  Node: Copying a TAVL Tree,  Next: Testing TAVL Trees,  Prev: Deleting from a TAVL Tree,  Up: Threaded AVL Trees

8.6 Copying
===========

We can use the tree copy function for TBSTs almost verbatim here.  The
one necessary change is that copy_node() must copy node balance
factors.  Here's the new version:

328. <TAVL node copy function 328> =
static int
copy_node (struct tavl_table *tree,
           struct tavl_node *dst, int dir,
           const struct tavl_node *src, tavl_copy_func *copy)
{
  struct tavl_node *new =
    tree->tavl_alloc->libavl_malloc (tree->tavl_alloc, sizeof *new);
  if (new == NULL)
    return 0;

  new->tavl_link[dir] = dst->tavl_link[dir];
  new->tavl_tag[dir] = TAVL_THREAD;
  new->tavl_link[!dir] = dst;
  new->tavl_tag[!dir] = TAVL_THREAD;
  dst->tavl_link[dir] = new;
  dst->tavl_tag[dir] = TAVL_CHILD;

  new->tavl_balance = src->tavl_balance;
  if (copy == NULL)
    new->tavl_data = src->tavl_data;
  else
    {
      new->tavl_data = copy (src->tavl_data, tree->tavl_param);
      if (new->tavl_data == NULL)
        return 0;
    }

  return 1;
}
   This code is included in *Note 329::.

329. <TAVL copy function 329> =
<*Note TAVL node copy function: 328.>
<*Note TBST copy error helper function; tbst => tavl: 280.>
<*Note TBST main copy function; tbst => tavl: 279.>
   This code is included in *Note 300:: and *Note 336::.


File: libavl.info,  Node: Testing TAVL Trees,  Prev: Copying a TAVL Tree,  Up: Threaded AVL Trees

8.7 Testing
===========

The testing code harbors no surprises.

330. <tavl-test.c 330> =
<*Note License: 1.>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "tavl.h"
#include "test.h"

<*Note TBST print function; tbst => tavl: 291.>
<*Note BST traverser check function; bst => tavl: 104.>
<*Note Compare two TAVL trees for structure and content: 331.>
<*Note Recursively verify TAVL tree structure: 332.>
<*Note AVL tree verify function; avl => tavl: 190.>
<*Note BST test function; bst => tavl: 100.>
<*Note BST overflow test function; bst => tavl: 122.>

331. <Compare two TAVL trees for structure and content 331> =
static int
compare_trees (struct tavl_node *a, struct tavl_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      if (a != NULL || b != NULL)
        {
          printf (" a=%d b=%d\n",
                  a ? *(int *) a->tavl_data : -1,
                  b ? *(int *) b->tavl_data : -1);
          assert (0);
        }
      return 1;
    }
  assert (a != b);

  if (*(int *) a->tavl_data != *(int *) b->tavl_data
      || a->tavl_tag[0] != b->tavl_tag[0]
      || a->tavl_tag[1] != b->tavl_tag[1]
      || a->tavl_balance != b->tavl_balance)
    {
      printf (" Copied nodes differ: a=%d (bal=%d) b=%d (bal=%d) a:",
              *(int *) a->tavl_data, a->tavl_balance,
              *(int *) b->tavl_data, b->tavl_balance);

      if (a->tavl_tag[0] == TAVL_CHILD)
        printf ("l");
      if (a->tavl_tag[1] == TAVL_CHILD)
        printf ("r");

      printf (" b:");
      if (b->tavl_tag[0] == TAVL_CHILD)
        printf ("l");
      if (b->tavl_tag[1] == TAVL_CHILD)
        printf ("r");

      printf ("\n");
      return 0;
    }

  if (a->tavl_tag[0] == TAVL_THREAD)
    assert ((a->tavl_link[0] == NULL) != (a->tavl_link[0] != b->tavl_link[0]));
  if (a->tavl_tag[1] == TAVL_THREAD)
    assert ((a->tavl_link[1] == NULL) != (a->tavl_link[1] != b->tavl_link[1]));

  okay = 1;
  if (a->tavl_tag[0] == TAVL_CHILD)
    okay &= compare_trees (a->tavl_link[0], b->tavl_link[0]);
  if (a->tavl_tag[1] == TAVL_CHILD)
    okay &= compare_trees (a->tavl_link[1], b->tavl_link[1]);
  return okay;
}
   This code is included in *Note 330::.

332. <Recursively verify TAVL tree structure 332> =
static void
recurse_verify_tree (struct tavl_node *node, int *okay, size_t *count,
                     int min, int max, int *height)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */
  int subheight[2];     /* Heights of subtrees. */

  if (node == NULL)
    {
      *count = 0;
      *height = 0;
      return;
    }
  d = *(int *) node->tavl_data;

  <*Note Verify binary search tree ordering: 114.>

  subcount[0] = subcount[1] = 0;
  subheight[0] = subheight[1] = 0;
  if (node->tavl_tag[0] == TAVL_CHILD)
    recurse_verify_tree (node->tavl_link[0], okay, &subcount[0],
                         min, d -  1, &subheight[0]);
  if (node->tavl_tag[1] == TAVL_CHILD)
    recurse_verify_tree (node->tavl_link[1], okay, &subcount[1],
                         d + 1, max, &subheight[1]);
  *count = 1 + subcount[0] + subcount[1];
  *height = 1 + (subheight[0] > subheight[1] ? subheight[0] : subheight[1]);

  <*Note Verify AVL node balance factor; avl => tavl: 189.>
}
   This code is included in *Note 330::.


File: libavl.info,  Node: Threaded Red-Black Trees,  Next: Right-Threaded Binary Search Trees,  Prev: Threaded AVL Trees,  Up: Top

9 Threaded Red-Black Trees
**************************

In the last two chapters, we introduced the idea of a threaded binary
search tree, then applied that idea to AVL trees to produce threaded AVL
trees.  In this chapter, we will apply the idea of threading to
red-black trees, resulting in threaded red-black or "TRB" trees.

   Here's an outline of the table implementation for threaded RB trees,
which use a trb_ prefix.

333. <trb.h 333> =
<*Note License: 1.>
#ifndef TRB_H
#define TRB_H 1

#include <stddef.h>

<*Note Table types; tbl => trb: 14.>
<*Note RB maximum height; rb => trb: 195.>
<*Note TBST table structure; tbst => trb: 250.>
<*Note TRB node structure: 335.>
<*Note TBST traverser structure; tbst => trb: 267.>
<*Note Table function prototypes; tbl => trb: 15.>

#endif /* trb.h */

334. <trb.c 334> =
<*Note License: 1.>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "trb.h"

<*Note TRB functions: 336.>

* Menu:

* TRB Data Types::
* TRB Operations::
* Inserting into a TRB Tree::
* Deleting from a TRB Tree::
* Testing TRB Trees::


File: libavl.info,  Node: TRB Data Types,  Next: TRB Operations,  Prev: Threaded Red-Black Trees,  Up: Threaded Red-Black Trees

9.1 Data Types
==============

To make a RB tree node structure into a threaded RB tree node structure,
we just add a pair of tag fields.  We also reintroduce a maximum height
definition here.  It is not used by traversers, only by by the default
versions of trb_probe() and trb_delete(), for maximum efficiency.

335. <TRB node structure 335> =
/* Color of a red-black node. */
enum trb_color
  {
    TRB_BLACK,                     /* Black. */
    TRB_RED                        /* Red. */
  };

/* Characterizes a link as a child pointer or a thread. */
enum trb_tag
  {
    TRB_CHILD,                     /* Child pointer. */
    TRB_THREAD                     /* Thread. */
  };

/* An TRB tree node. */
struct trb_node
  {
    struct trb_node *trb_link[2];  /* Subtrees. */
    void *trb_data;                /* Pointer to data. */
    unsigned char trb_color;       /* Color. */
    unsigned char trb_tag[2];      /* Tag fields. */
  };
   This code is included in *Note 333::.


File: libavl.info,  Node: TRB Operations,  Next: Inserting into a TRB Tree,  Prev: TRB Data Types,  Up: Threaded Red-Black Trees

9.2 Operations
==============

Now we'll implement all the usual operations for TRB trees.  Here's the
outline.  We can reuse everything from TBSTs except insertion, deletion,
and copy functions.  The copy function is implemented by reusing the
version for TAVL trees, but copying colors instead of balance factors.

336. <TRB functions 336> =
<*Note TBST creation function; tbst => trb: 252.>
<*Note TBST search function; tbst => trb: 253.>
<*Note TRB item insertion function: 337.>
<*Note Table insertion convenience functions; tbl => trb: 592.>
<*Note TRB item deletion function: 349.>
<*Note TBST traversal functions; tbst => trb: 268.>
<*Note TAVL copy function; tavl => trb; tavl_balance => trb_color: 329.>
<*Note TBST destruction function; tbst => trb: 281.>
<*Note Default memory allocation functions; tbl => trb: 6.>
<*Note Table assertion functions; tbl => trb: 594.>
   This code is included in *Note 334::.


File: libavl.info,  Node: Inserting into a TRB Tree,  Next: Deleting from a TRB Tree,  Prev: TRB Operations,  Up: Threaded Red-Black Trees

9.3 Insertion
=============

The structure of the insertion routine is predictable:

337. <TRB item insertion function 337> =
void **
trb_probe (struct trb_table *tree, void *item)
{
  struct trb_node *pa[TRB_MAX_HEIGHT]; /* Nodes on stack. */
  unsigned char da[TRB_MAX_HEIGHT];    /* Directions moved from stack nodes. */
  int k;                               /* Stack height. */

  struct trb_node *p; /* Traverses tree looking for insertion point. */
  struct trb_node *n; /* Newly inserted node. */
  int dir;            /* Side of p on which n is inserted. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search TRB tree for insertion point: 338.>
  <*Note Step 2: Insert TRB node: 339.>
  <*Note Step 3: Rebalance after TRB insertion: 340.>

  return &n->trb_data;
}
   This code is included in *Note 336::.

* Menu:

* Steps 1 and 2 in TRB Insertion::
* Step 3 in TRB Insertion::
* TRB Insertion Symmetric Case::


File: libavl.info,  Node: Steps 1 and 2 in TRB Insertion,  Next: Step 3 in TRB Insertion,  Prev: Inserting into a TRB Tree,  Up: Inserting into a TRB Tree

9.3.1 Steps 1 and 2: Search and Insert
--------------------------------------

As usual, we search the tree from the root and record parents as we go.

338. <Step 1: Search TRB tree for insertion point 338> =
da[0] = 0;
pa[0] = (struct trb_node *) &tree->trb_root;
k = 1;
if (tree->trb_root != NULL)
  {
    for (p = tree->trb_root; ; p = p->trb_link[dir])
      {
        int cmp = tree->trb_compare (item, p->trb_data, tree->trb_param);
        if (cmp == 0)
          return &p->trb_data;

        pa[k] = p;
        da[k++] = dir = cmp > 0;

        if (p->trb_tag[dir] == TRB_THREAD)
          break;
      }
  }
else
  {
    p = (struct trb_node *) &tree->trb_root;
    dir = 0;
  }
   This code is included in *Note 337::.

   The code for insertion is included within the loop for easy access to
the dir variable.

339. <Step 2: Insert TRB node 339> =
<*Note Step 2: Insert TBST node; tbst => trb: 256.>
n->trb_color = TRB_RED;
   This code is included in *Note 337:: and *Note 668::.


File: libavl.info,  Node: Step 3 in TRB Insertion,  Next: TRB Insertion Symmetric Case,  Prev: Steps 1 and 2 in TRB Insertion,  Up: Inserting into a TRB Tree

9.3.2 Step 3: Rebalance
-----------------------

The basic rebalancing loop is unchanged from <*Note Step 3: Rebalance
after RB insertion: 201.>.

340. <Step 3: Rebalance after TRB insertion 340> =
while (k >= 3 && pa[k - 1]->trb_color == TRB_RED)
  {
    if (da[k - 2] == 0)
      {
        <*Note Left-side rebalancing after TRB insertion: 341.>
      }
    else
      {
        <*Note Right-side rebalancing after TRB insertion: 345.>
      }
  }
tree->trb_root->trb_color = TRB_BLACK;
   This code is included in *Note 337::.

   The cases for rebalancing are the same as in <*Note Left-side
rebalancing after RB insertion: 202.>, too.  We do need to check for
threads, instead of null pointers.

341. <Left-side rebalancing after TRB insertion 341> =
struct trb_node *y = pa[k - 2]->trb_link[1];
if (pa[k - 2]->trb_tag[1] == TRB_CHILD && y->trb_color == TRB_RED)
  {
    <*Note Case 1 in left-side TRB insertion rebalancing: 342.>
  }
else
  {
    struct trb_node *x;

    if (da[k - 1] == 0)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in left-side TRB insertion rebalancing: 344.>
      }

    <*Note Case 2 in left-side TRB insertion rebalancing: 343.>
    break;
  }
   This code is included in *Note 340::.

   The rest of this section deals with the individual rebalancing cases,
the same as in unthreaded RB insertion (*note Inserting an RB Node Step
3 - Rebalance::).  Each iteration deals with a node whose color has
just been changed to red, which is the newly inserted node n in the
first trip through the loop.  In the discussion, we'll call this node q.

Case 1: q's uncle is red
........................

If node q has an red "uncle", then only recoloring is required.
Because no links are changed, no threads need to be updated, and we can
reuse the code for RB insertion without change:

342. <Case 1 in left-side TRB insertion rebalancing 342> =
<*Note Case 1 in left-side RB insertion rebalancing; rb => trb: 203.>
   This code is included in *Note 341::.

Case 2: q is the left child of its parent
.........................................

If q is the left child of its parent, we rotate right at q's
grandparent, and recolor a few nodes.  Here's the transformation:

 [image src="rbins2.png" text="                                 |
                             pa[k-2],x              |
                                <b>                 y
                   ___...---'         \\            <b>
                  pa[k-1],y            d       _.-'   `_
                     <r>                 =>    q         x
              _.-'         \\                  <r>       <r>
              q             c                /   \\     /   \\
             <r>                            a     b   c     d
            /   \\
           a     b

" ]

This transformation can only cause thread problems with subtree c,
since the other subtrees stay firmly in place.  If c is a thread, then
we need to make adjustments after the transformation to account for the
difference between threaded and unthreaded rotation, so that the final
operation looks like this:

 [image src="trbins.png" text="                                  |
                              pa[k-2],x              |
                                 <b>                 y
                  ____....---'         \\            <b>
                 pa[k-1],y              d       _.-'   `._
                    <r>                   =>    q          x
             _.-'         \\                    <r>        <r>
             q             [x]                /   \\     _'   \\
            <r>                              a     b   [y]    d
           /   \\
          a     b

" ]

343. <Case 2 in left-side TRB insertion rebalancing 343> =
<*Note Case 2 in left-side RB insertion rebalancing; rb => trb: 204.>

if (y->trb_tag[1] == TRB_THREAD)
  {
    y->trb_tag[1] = TRB_CHILD;
    x->trb_tag[0] = TRB_THREAD;
    x->trb_link[0] = y;
  }
This code is included in *Note 341::.

Case 3: q is the right child of its parent
..........................................

The modification to case 3 is the same as the modification to case 2,
but it applies to a left rotation instead of a right rotation.  The
adjusted case looks like this:

 [image src="trbins2.png" text="                                 |                        |
                              pa[k-2]                    <b>
                                <b>                  _.-'   \\
              _____.....-----'       \\               y       d
             pa[k-1],x                d             <r>
                <r>                     =>    __..-'   \\
            /         `._                     x         c
           a             w,y                 <r>
                         <r>                /   \\
                       _'   \\              a     [y]
                      [x]    c

" ]

344. <Case 3 in left-side TRB insertion rebalancing 344> =
<*Note Case 3 in left-side RB insertion rebalancing; rb => trb: 205.>

if (y->trb_tag[0] == TRB_THREAD)
  {
    y->trb_tag[0] = TRB_CHILD;
    x->trb_tag[1] = TRB_THREAD;
    x->trb_link[1] = y;
  }
This code is included in *Note 341::.


File: libavl.info,  Node: TRB Insertion Symmetric Case,  Prev: Step 3 in TRB Insertion,  Up: Inserting into a TRB Tree

9.3.3 Symmetric Case
--------------------

345. <Right-side rebalancing after TRB insertion 345> =
struct trb_node *y = pa[k - 2]->trb_link[0];
if (pa[k - 2]->trb_tag[0] == TRB_CHILD && y->trb_color == TRB_RED)
  {
    <*Note Case 1 in right-side TRB insertion rebalancing: 346.>
  }
else
  {
    struct trb_node *x;

    if (da[k - 1] == 1)
      y = pa[k - 1];
    else
      {
        <*Note Case 3 in right-side TRB insertion rebalancing: 348.>
      }

    <*Note Case 2 in right-side TRB insertion rebalancing: 347.>
    break;
  }
This code is included in *Note 340::.

346. <Case 1 in right-side TRB insertion rebalancing 346> =
<*Note Case 1 in right-side RB insertion rebalancing; rb => trb: 207.>
   This code is included in *Note 345::.

347. <Case 2 in right-side TRB insertion rebalancing 347> =
<*Note Case 2 in right-side RB insertion rebalancing; rb => trb: 208.>

if (y->trb_tag[0] == TRB_THREAD)
  {
    y->trb_tag[0] = TRB_CHILD;
    x->trb_tag[1] = TRB_THREAD;
    x->trb_link[1] = y;
  }
   This code is included in *Note 345::.

348. <Case 3 in right-side TRB insertion rebalancing 348> =
<*Note Case 3 in right-side RB insertion rebalancing; rb => trb: 209.>

if (y->trb_tag[1] == TRB_THREAD)
  {
    y->trb_tag[1] = TRB_CHILD;
    x->trb_tag[0] = TRB_THREAD;
    x->trb_link[0] = y;
  }
   This code is included in *Note 345::.

Exercises:

1. It could be argued that the algorithm here is "impure" because it
uses a stack, when elimination of the need for a stack is one of the
reasons originally given for using threaded trees.  Write a version of
trb_probe() that avoids the use of a stack.  You can use find_parent()
from <*Note Find parent of a TBST node: 327.> as a substitute.  [*Note
answer: 9-3-3#1..]


File: libavl.info,  Node: Deleting from a TRB Tree,  Next: Testing TRB Trees,  Prev: Inserting into a TRB Tree,  Up: Threaded Red-Black Trees

9.4 Deletion
============

The outline for the deletion function follows the usual pattern.

349. <TRB item deletion function 349> =
void *
trb_delete (struct trb_table *tree, const void *item)
{
  struct trb_node *pa[TRB_MAX_HEIGHT]; /* Nodes on stack. */
  unsigned char da[TRB_MAX_HEIGHT];    /* Directions moved from stack nodes. */
  int k = 0;                           /* Stack height. */

  struct trb_node *p;
  int cmp, dir;

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search TRB tree for item to delete: 350.>
  <*Note Step 2: Delete item from TRB tree: 351.>
  <*Note Step 3: Rebalance tree after TRB deletion: 356.>
  <*Note Step 4: Finish up after TRB deletion: 362.>
}
   This code is included in *Note 336::.

* Menu:

* Deleting a TRB Node Step 1 - Search::
* Deleting a TRB Node Step 2 - Delete::
* Deleting a TRB Node Step 3 - Rebalance::
* Deleting a TRB Node Step 4 - Finish Up::
* TRB Deletion Symmetric Case::


File: libavl.info,  Node: Deleting a TRB Node Step 1 - Search,  Next: Deleting a TRB Node Step 2 - Delete,  Prev: Deleting from a TRB Tree,  Up: Deleting from a TRB Tree

9.4.1 Step 1: Search
--------------------

There's nothing new or interesting in the search code.

350. <Step 1: Search TRB tree for item to delete 350> =
if (tree->trb_root == NULL)
  return NULL;

p = (struct trb_node *) &tree->trb_root;
for (cmp = -1; cmp != 0;
     cmp = tree->trb_compare (item, p->trb_data, tree->trb_param))
  {
    dir = cmp > 0;
    pa[k] = p;
    da[k++] = dir;

    if (p->trb_tag[dir] == TRB_THREAD)
      return NULL;
    p = p->trb_link[dir];
  }
item = p->trb_data;
   This code is included in *Note 349:: and *Note 659::.


File: libavl.info,  Node: Deleting a TRB Node Step 2 - Delete,  Next: Deleting a TRB Node Step 3 - Rebalance,  Prev: Deleting a TRB Node Step 1 - Search,  Up: Deleting from a TRB Tree

9.4.2 Step 2: Delete
--------------------

The code for node deletion is a combination of RB deletion (*note
Deleting an RB Node Step 2 - Delete::) and TBST deletion (*note
Deleting from a TBST::).  The node to delete is p, and after deletion
the stack contains all the nodes down to where rebalancing begins.  The
cases are the same as for TBST deletion:

351. <Step 2: Delete item from TRB tree 351> =
if (p->trb_tag[1] == TRB_THREAD)
  {
    if (p->trb_tag[0] == TRB_CHILD)
      {
        <*Note Case 1 in TRB deletion: 352.>
      }
    else
      {
        <*Note Case 2 in TRB deletion: 353.>
      }
  }
else
  {
    enum trb_color t;
    struct trb_node *r = p->trb_link[1];

    if (r->trb_tag[0] == TRB_THREAD)
      {
        <*Note Case 3 in TRB deletion: 354.>
      }
    else
      {
        <*Note Case 4 in TRB deletion: 355.>
      }
  }
   This code is included in *Note 349::.

Case 1: p has a right thread and a left child
.............................................

If the node to delete p has a right thread and a left child, then we
replace it by its left child.  We also have to chase down the right
thread that pointed to p.  The code is almost the same as <*Note Case 1
in TBST deletion: 260.>, but we use the stack here instead of a single
parent pointer.

352. <Case 1 in TRB deletion 352> =
struct trb_node *t = p->trb_link[0];
while (t->trb_tag[1] == TRB_CHILD)
  t = t->trb_link[1];
t->trb_link[1] = p->trb_link[1];
pa[k - 1]->trb_link[da[k - 1]] = p->trb_link[0];
   This code is included in *Note 351::.

Case 2: p has a right thread and a left thread
..............................................

Deleting a leaf node is the same process as for a TBST.  The changes
from <*Note Case 2 in TBST deletion: 261.> are again due to the use of
a stack.

353. <Case 2 in TRB deletion 353> =
pa[k - 1]->trb_link[da[k - 1]] = p->trb_link[da[k - 1]];
if (pa[k - 1] != (struct trb_node *) &tree->trb_root)
  pa[k - 1]->trb_tag[da[k - 1]] = TRB_THREAD;
   This code is included in *Note 351::.

Case 3: p's right child has a left thread
.........................................

The code for case 3 merges <*Note Case 3 in TBST deletion: 262.> with
<*Note Case 2 in RB deletion: 223.>.  First, the node is deleted in the
same way used for a TBST.  Then the colors of p and r are swapped, and
r is added to the stack, in the same way as for RB deletion.

354. <Case 3 in TRB deletion 354> =
r->trb_link[0] = p->trb_link[0];
r->trb_tag[0] = p->trb_tag[0];
if (r->trb_tag[0] == TRB_CHILD)
  {
    struct trb_node *t = r->trb_link[0];
    while (t->trb_tag[1] == TRB_CHILD)
      t = t->trb_link[1];
    t->trb_link[1] = r;
  }
pa[k - 1]->trb_link[da[k - 1]] = r;
t = r->trb_color;
r->trb_color = p->trb_color;
p->trb_color = t;
da[k] = 1;
pa[k++] = r;
   This code is included in *Note 351::.

Case 4: p's right child has a left child
........................................

Case 4 is a mix of <*Note Case 4 in TBST deletion: 263.> and <*Note
Case 3 in RB deletion: 224.>.  It follows the outline of TBST deletion,
but updates the stack.  After the deletion it also swaps the colors of
p and s as in RB deletion.

355. <Case 4 in TRB deletion 355> =
struct trb_node *s;
int j = k++;

for (;;)
  {
    da[k] = 0;
    pa[k++] = r;
    s = r->trb_link[0];
    if (s->trb_tag[0] == TRB_THREAD)
      break;

    r = s;
  }

da[j] = 1;
pa[j] = s;
if (s->trb_tag[1] == TRB_CHILD)
  r->trb_link[0] = s->trb_link[1];
else
  {
    r->trb_link[0] = s;
    r->trb_tag[0] = TRB_THREAD;
  }

s->trb_link[0] = p->trb_link[0];
if (p->trb_tag[0] == TRB_CHILD)
  {
    struct trb_node *t = p->trb_link[0];
    while (t->trb_tag[1] == TRB_CHILD)
      t = t->trb_link[1];
    t->trb_link[1] = s;

    s->trb_tag[0] = TRB_CHILD;
  }

s->trb_link[1] = p->trb_link[1];
s->trb_tag[1] = TRB_CHILD;

t = s->trb_color;
s->trb_color = p->trb_color;
p->trb_color = t;

pa[j - 1]->trb_link[da[j - 1]] = s;
   This code is included in *Note 351::.

Exercises:

1. Rewrite <*Note Case 4 in TAVL deletion: 317.> to replace the deleted
node's tavl_data by its successor, then delete the successor, instead of
shuffling pointers.  (Refer back to Exercise 4.8-3 for an explanation
of why this approach cannot be used in libavl.)  [*Note answer:
9-4-2#1..]


File: libavl.info,  Node: Deleting a TRB Node Step 3 - Rebalance,  Next: Deleting a TRB Node Step 4 - Finish Up,  Prev: Deleting a TRB Node Step 2 - Delete,  Up: Deleting from a TRB Tree

9.4.3 Step 3: Rebalance
-----------------------

The outline for rebalancing after threaded RB deletion is the same as
for the unthreaded case (*note Deleting an RB Node Step 3 -
Rebalance::):

356. <Step 3: Rebalance tree after TRB deletion 356> =
if (p->trb_color == TRB_BLACK)
  {
    for (; k > 1; k-)
      {
        if (pa[k - 1]->trb_tag[da[k - 1]] == TRB_CHILD)
          {
            struct trb_node *x = pa[k - 1]->trb_link[da[k - 1]];
            if (x->trb_color == TRB_RED)
              {
                x->trb_color = TRB_BLACK;
                break;
              }
          }

        if (da[k - 1] == 0)
          {
            <*Note Left-side rebalancing after TRB deletion: 357.>
          }
        else
          {
            <*Note Right-side rebalancing after TRB deletion: 363.>
          }
      }

    if (tree->trb_root != NULL)
      tree->trb_root->trb_color = TRB_BLACK;
  }
   This code is included in *Note 349::.

   The rebalancing cases are the same, too.  We need to check for thread
tags, not for null pointers, though, in some places:

357. <Left-side rebalancing after TRB deletion 357> =
struct trb_node *w = pa[k - 1]->trb_link[1];

if (w->trb_color == TRB_RED)
  {
    <*Note Ensure w is black in left-side TRB deletion rebalancing: 358.>
  }

if ((w->trb_tag[0] == TRB_THREAD
     || w->trb_link[0]->trb_color == TRB_BLACK)
    && (w->trb_tag[1] == TRB_THREAD
        || w->trb_link[1]->trb_color == TRB_BLACK))
  {
    <*Note Case 1 in left-side TRB deletion rebalancing: 359.>
  }
else
  {
    if (w->trb_tag[1] == TRB_THREAD
        || w->trb_link[1]->trb_color == TRB_BLACK)
      {
        <*Note Transform left-side TRB deletion rebalancing case 3 into case 2: 361.>
      }

    <*Note Case 2 in left-side TRB deletion rebalancing: 360.>
    break;
  }
   This code is included in *Note 356::.

Case Reduction: Ensure w is black
.................................

This transformation does not move around any subtrees that might be
threads, so there is no need for it to change.

358. <Ensure w is black in left-side TRB deletion rebalancing 358> =
<*Note Ensure w is black in left-side RB deletion rebalancing; rb => trb: 228.>
   This code is included in *Note 357::.

Case 1: w has no red children
.............................

This transformation just recolors nodes, so it also does not need any
changes.

359. <Case 1 in left-side TRB deletion rebalancing 359> =
<*Note Case 1 in left-side RB deletion rebalancing; rb => trb: 229.>
   This code is included in *Note 357::.

Case 2: w's right child is red
..............................

If w has a red right child and a left thread, then it is necessary to
adjust tags and links after the left rotation at w and recoloring, as
shown in this diagram:

 [image src="trbdel.png" text="                   |                                    |
               pa[x-1],B                                C
                  <g>                                  <g>
           _.-'         `._                      __..-'   `_
          x,A              w,C                   B           D
          <b>              <b>        =>        <b>         <b>
         /   \\           _'   `_            _.-'   \\       /   \\
        a     b         [B]      D          A       [C]   d     e
                                <r>        <b>
                               /   \\      /   \\
                              d     e    a     b

" ]

360. <Case 2 in left-side TRB deletion rebalancing 360> =
<*Note Case 2 in left-side RB deletion rebalancing; rb => trb: 230.>

if (w->trb_tag[0] == TRB_THREAD)
  {
    w->trb_tag[0] = TRB_CHILD;
    pa[k - 1]->trb_tag[1] = TRB_THREAD;
    pa[k - 1]->trb_link[1] = w;
  }
This code is included in *Note 357::.

Case 3: w's left child is red
.............................

If w has a red left child, which has a right thread, then we again need
to adjust tags and links after right rotation at w and recoloring, as
shown here:

 [image src="trbdel2.png" text="                |                                 |
            pa[k-1],B                         pa[k-1],B
               <g>                               <g>
        _.-'         `--...___            _.-'         `_
       x,A                    w,D        x,A             w,C
       <b>                    <b>   =>   <b>             <b>
      /   \\             __..-'   \\      /   \\           /   `._
     a     b            C         e    a     b         c        D
                       <r>                                     <r>
                      /   \\                                  _'   \\
                     c     [D]                              [C]    e

" ]

361. <Transform left-side TRB deletion rebalancing case 3 into case 2 361> =
<*Note Transform left-side RB deletion rebalancing case 3 into case 2; rb => trb: 231.>

if (w->trb_tag[1] == TRB_THREAD)
  {
    w->trb_tag[1] = TRB_CHILD;
    w->trb_link[1]->trb_tag[0] = TRB_THREAD;
    w->trb_link[1]->trb_link[0] = w;
  }
This code is included in *Note 357::.


File: libavl.info,  Node: Deleting a TRB Node Step 4 - Finish Up,  Next: TRB Deletion Symmetric Case,  Prev: Deleting a TRB Node Step 3 - Rebalance,  Up: Deleting from a TRB Tree

9.4.4 Step 4: Finish Up
-----------------------

All that's left to do is free the node, update the count, and return the
deleted item:

362. <Step 4: Finish up after TRB deletion 362> =
tree->trb_alloc->libavl_free (tree->trb_alloc, p);
tree->trb_count-;
return (void *) item;
   This code is included in *Note 349::.


File: libavl.info,  Node: TRB Deletion Symmetric Case,  Prev: Deleting a TRB Node Step 4 - Finish Up,  Up: Deleting from a TRB Tree

9.4.5 Symmetric Case
--------------------

363. <Right-side rebalancing after TRB deletion 363> =
struct trb_node *w = pa[k - 1]->trb_link[0];

if (w->trb_color == TRB_RED)
  {
    <*Note Ensure w is black in right-side TRB deletion rebalancing: 364.>
  }

if ((w->trb_tag[0] == TRB_THREAD
     || w->trb_link[0]->trb_color == TRB_BLACK)
    && (w->trb_tag[1] == TRB_THREAD
        || w->trb_link[1]->trb_color == TRB_BLACK))
  {
    <*Note Case 1 in right-side TRB deletion rebalancing: 365.>
  }
else
  {
    if (w->trb_tag[0] == TRB_THREAD
        || w->trb_link[0]->trb_color == TRB_BLACK)
      {
        <*Note Transform right-side TRB deletion rebalancing case 3 into case 2: 367.>
      }

    <*Note Case 2 in right-side TRB deletion rebalancing: 366.>
    break;
  }
This code is included in *Note 356::.

364. <Ensure w is black in right-side TRB deletion rebalancing 364> =
<*Note Ensure w is black in right-side RB deletion rebalancing; rb => trb: 234.>
   This code is included in *Note 363::.

365. <Case 1 in right-side TRB deletion rebalancing 365> =
<*Note Case 1 in right-side RB deletion rebalancing; rb => trb: 235.>
   This code is included in *Note 363::.

366. <Case 2 in right-side TRB deletion rebalancing 366> =
<*Note Case 2 in right-side RB deletion rebalancing; rb => trb: 237.>

if (w->trb_tag[1] == TRB_THREAD)
  {
    w->trb_tag[1] = TRB_CHILD;
    pa[k - 1]->trb_tag[0] = TRB_THREAD;
    pa[k - 1]->trb_link[0] = w;
  }
   This code is included in *Note 363::.

367. <Transform right-side TRB deletion rebalancing case 3 into case 2 367> =
<*Note Transform right-side RB deletion rebalancing case 3 into case 2; rb => trb: 236.>

if (w->trb_tag[0] == TRB_THREAD)
  {
    w->trb_tag[0] = TRB_CHILD;
    w->trb_link[0]->trb_tag[1] = TRB_THREAD;
    w->trb_link[0]->trb_link[1] = w;
  }
   This code is included in *Note 363::.

Exercises:

1. Write another version of trb_delete() that does not use a stack.  You
can use <*Note Find parent of a TBST node: 327.> to find the parent of
a node.  [*Note answer: 9-4-5#1..]


File: libavl.info,  Node: Testing TRB Trees,  Prev: Deleting from a TRB Tree,  Up: Threaded Red-Black Trees

9.5 Testing
===========

The testing code harbors no surprises.

368. <trb-test.c 368> =
<*Note License: 1.>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "trb.h"
#include "test.h"

<*Note TBST print function; tbst => trb: 291.>
<*Note BST traverser check function; bst => trb: 104.>
<*Note Compare two TRB trees for structure and content: 369.>
<*Note Recursively verify TRB tree structure: 370.>
<*Note RB tree verify function; rb => trb: 244.>
<*Note BST test function; bst => trb: 100.>
<*Note BST overflow test function; bst => trb: 122.>

369. <Compare two TRB trees for structure and content 369> =
static int
compare_trees (struct trb_node *a, struct trb_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      if (a != NULL || b != NULL)
        {
          printf (" a=%d b=%d\n",
                  a ? *(int *) a->trb_data : -1,
                  b ? *(int *) b->trb_data : -1);
          assert (0);
        }
      return 1;
    }
  assert (a != b);

  if (*(int *) a->trb_data != *(int *) b->trb_data
      || a->trb_tag[0] != b->trb_tag[0]
      || a->trb_tag[1] != b->trb_tag[1]
      || a->trb_color != b->trb_color)
    {
      printf (" Copied nodes differ: a=%d%c b=%d%c a:",
              *(int *) a->trb_data, a->trb_color == TRB_RED ? 'r' : 'b',
              *(int *) b->trb_data, b->trb_color == TRB_RED ? 'r' : 'b');

      if (a->trb_tag[0] == TRB_CHILD)
        printf ("l");
      if (a->trb_tag[1] == TRB_CHILD)
        printf ("r");

      printf (" b:");
      if (b->trb_tag[0] == TRB_CHILD)
        printf ("l");
      if (b->trb_tag[1] == TRB_CHILD)
        printf ("r");

      printf ("\n");
      return 0;
    }

  if (a->trb_tag[0] == TRB_THREAD)
    assert ((a->trb_link[0] == NULL) != (a->trb_link[0] != b->trb_link[0]));
  if (a->trb_tag[1] == TRB_THREAD)
    assert ((a->trb_link[1] == NULL) != (a->trb_link[1] != b->trb_link[1]));

  okay = 1;
  if (a->trb_tag[0] == TRB_CHILD)
    okay &= compare_trees (a->trb_link[0], b->trb_link[0]);
  if (a->trb_tag[1] == TRB_CHILD)
    okay &= compare_trees (a->trb_link[1], b->trb_link[1]);
  return okay;
}
   This code is included in *Note 368::.

370. <Recursively verify TRB tree structure 370> =
static void
recurse_verify_tree (struct trb_node *node, int *okay, size_t *count,
                     int min, int max, int *bh)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */
  int subbh[2];         /* Black-heights of subtrees. */

  if (node == NULL)
    {
      *count = 0;
      *bh = 0;
      return;
    }
  d = *(int *) node->trb_data;

  <*Note Verify binary search tree ordering: 114.>

  subcount[0] = subcount[1] = 0;
  subbh[0] = subbh[1] = 0;
  if (node->trb_tag[0] == TRB_CHILD)
    recurse_verify_tree (node->trb_link[0], okay, &subcount[0],
                         min, d - 1, &subbh[0]);
  if (node->trb_tag[1] == TRB_CHILD)
    recurse_verify_tree (node->trb_link[1], okay, &subcount[1],
                         d + 1, max, &subbh[1]);
  *count = 1 + subcount[0] + subcount[1];
  *bh = (node->trb_color == TRB_BLACK) + subbh[0];

  <*Note Verify RB node color; rb => trb: 241.>
  <*Note Verify TRB node rule 1 compliance: 371.>
  <*Note Verify RB node rule 2 compliance; rb => trb: 243.>
}
   This code is included in *Note 368::.

371. <Verify TRB node rule 1 compliance 371> =
/* Verify compliance with rule 1. */
if (node->trb_color == TRB_RED)
  {
    if (node->trb_tag[0] == TRB_CHILD
        && node->trb_link[0]->trb_color == TRB_RED)
      {
        printf (" Red node %d has red left child %d\n",
                d, *(int *) node->trb_link[0]->trb_data);
        *okay = 0;
      }

    if (node->trb_tag[1] == TRB_CHILD
        && node->trb_link[1]->trb_color == TRB_RED)
      {
        printf (" Red node %d has red right child %d\n",
                d, *(int *) node->trb_link[1]->trb_data);
        *okay = 0;
      }
  }
   This code is included in *Note 370::.


File: libavl.info,  Node: Right-Threaded Binary Search Trees,  Next: Right-Threaded AVL Trees,  Prev: Threaded Red-Black Trees,  Up: Top

10 Right-Threaded Binary Search Trees
*************************************

We originally introduced threaded trees to allow for traversal without
maintaining a stack explicitly.  This worked out well, so we implemented
tables using threaded BSTs and AVL and RB trees.  However, maintaining
the threads can take some time.  It would be nice if we could have the
advantages of threads without so much of the overhead.

   In one common special case, we can.  Threaded trees are symmetric:
there are left threads for moving to node predecessors and right
threads for move to node successors.  But traversals are not symmetric:
many algorithms that traverse table entries only from least to
greatest, never backing up.  This suggests a matching asymmetric tree
structure that has only right threads.

   We can do this.  In this chapter, we will develop a table
implementation for a new kind of binary tree, called a right-threaded
binary search tree, "right-threaded tree" (*note right-threaded
tree::), or simply "RTBST", that has threads only on the right side of
nodes.  Construction and modification of such trees can be faster and
simpler than threaded trees because there is no need to maintain the
left threads.

   There isn't anything fundamentally new here, but just for
completeness, here's an example of a right-threaded tree:

 [image src="rtbst1.png" text="                               3
                           _.-' `--..__
                          2            6
                      _.-' \\     __..-' `-.__
                     1      [3] 4            8
                      \\          \\       _.-' \\
                       [2]        5     7      9
                                   \\     \\      \\
                                    [6]   [8]    []

" ]

Keep in mind that although it is not efficient, it is still possible to
traverse a right-threaded tree in order from greatest to least.(1)  If
it were not possible at all, then we could not build a complete table
implementation based on right-threaded trees, because the definition of
a table includes the ability to traverse it in either direction (*note
Manipulators::).

   Here's the outline of the RTBST code, which uses the prefix rtbst_:

372. <rtbst.h 372> =
<*Note License: 1.>
#ifndef RTBST_H
#define RTBST_H 1

#include <stddef.h>

<*Note Table types; tbl => rtbst: 14.>
<*Note TBST table structure; tbst => rtbst: 250.>
<*Note RTBST node structure: 374.>
<*Note TBST traverser structure; tbst => rtbst: 267.>
<*Note Table function prototypes; tbl => rtbst: 15.>
<*Note BST extra function prototypes; bst => rtbst: 88.>

#endif /* rtbst.h */

373. <rtbst.c 373> =
<*Note License: 1.>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "rtbst.h"

<*Note RTBST functions: 375.>

See also:  *Note Knuth 1997::, section 2.3.1.

Exercises:

1. We can define a "left-threaded tree" (*note left-threaded tree::) in
a way analogous to a right-threaded tree, as a binary search tree with
threads only on the left sides of nodes.  Is this a useful thing to do?
[*Note answer: 10#1..]

* Menu:

* RTBST Data Types::
* RTBST Operations::
* Searching an RTBST::
* Inserting into an RTBST::
* Deleting from an RTBST::
* Traversing an RTBST::
* Copying an RTBST::
* Destroying an RTBST::
* Balancing an RTBST::
* Testing RTBSTs::

   ---------- Footnotes ----------

   (1) It can be efficient if we use a stack to do it, but that kills
the advantage of threading the tree.  It would be possible to implement
two sets of traversers for right-threaded trees, one with a stack, one
without, but in that case it's probably better to just use a threaded
tree.


File: libavl.info,  Node: RTBST Data Types,  Next: RTBST Operations,  Prev: Right-Threaded Binary Search Trees,  Up: Right-Threaded Binary Search Trees

10.1 Data Types
===============

374. <RTBST node structure 374> =
/* Characterizes a link as a child pointer or a thread. */
enum rtbst_tag
  {
    RTBST_CHILD,                     /* Child pointer. */
    RTBST_THREAD                     /* Thread. */
  };

/* A threaded binary search tree node. */
struct rtbst_node
  {
    struct rtbst_node *rtbst_link[2]; /* Subtrees. */
    void *rtbst_data;                 /* Pointer to data. */
    unsigned char rtbst_rtag;         /* Tag field. */
  };
This code is included in *Note 372::.


File: libavl.info,  Node: RTBST Operations,  Next: Searching an RTBST,  Prev: RTBST Data Types,  Up: Right-Threaded Binary Search Trees

10.2 Operations
===============

375. <RTBST functions 375> =
<*Note TBST creation function; tbst => rtbst: 252.>
<*Note RTBST search function: 376.>
<*Note RTBST item insertion function: 377.>
<*Note Table insertion convenience functions; tbl => rtbst: 592.>
<*Note RTBST item deletion function: 380.>
<*Note RTBST traversal functions: 395.>
<*Note RTBST copy function: 406.>
<*Note RTBST destruction function: 407.>
<*Note RTBST balance function: 408.>
<*Note Default memory allocation functions; tbl => rtbst: 6.>
<*Note Table assertion functions; tbl => rtbst: 594.>
This code is included in *Note 373::.


File: libavl.info,  Node: Searching an RTBST,  Next: Inserting into an RTBST,  Prev: RTBST Operations,  Up: Right-Threaded Binary Search Trees

10.3 Search
===========

A right-threaded tree is inherently asymmetric, so many of the
algorithms on it will necessarily be asymmetric as well.  The search
function is the simplest demonstration of this.  For descent to the
left, we test for a null left child with rtbst_link[0]; for descent to
the right, we test for a right thread with rtbst_rtag.  Otherwise, the
code is familiar:

376. <RTBST search function 376> =
void *
rtbst_find (const struct rtbst_table *tree, const void *item)
{
  const struct rtbst_node *p;
  int dir;

  assert (tree != NULL && item != NULL);

  if (tree->rtbst_root == NULL)
    return NULL;

  for (p = tree->rtbst_root; ; p = p->rtbst_link[dir])
    {
      int cmp = tree->rtbst_compare (item, p->rtbst_data, tree->rtbst_param);
      if (cmp == 0)
        return p->rtbst_data;
      dir = cmp > 0;

      if (dir == 0)
        {
          if (p->rtbst_link[0] == NULL)
            return NULL;
        }
      else /* dir == 1 */
        {
          if (p->rtbst_rtag == RTBST_THREAD)
            return NULL;
        }
    }
}
   This code is included in *Note 375::, *Note 418::, and *Note 455::.


File: libavl.info,  Node: Inserting into an RTBST,  Next: Deleting from an RTBST,  Prev: Searching an RTBST,  Up: Right-Threaded Binary Search Trees

10.4 Insertion
==============

Regardless of the kind of binary tree we're dealing with, adding a new
node requires setting three pointer fields: the parent pointer and the
two child pointers of the new node.  On the other hand, we do save a
tiny bit on tags: we set either 1 or 2 tags here as opposed to a
constant of 3 in <*Note TBST item insertion function: 254.>.

   Here is the outline:

377. <RTBST item insertion function 377> =
void **
rtbst_probe (struct rtbst_table *tree, void *item)
{
  struct rtbst_node *p; /* Current node in search. */
  int dir;              /* Side of p on which to insert the new node. */

  struct rtbst_node *n; /* New node. */

  <*Note Step 1: Search RTBST for insertion point: 378.>
  <*Note Step 2: Insert new node into RTBST tree: 379.>
}
   This code is included in *Note 375::.

   The code to search for the insertion point is not unusual:

378. <Step 1: Search RTBST for insertion point 378> =
if (tree->rtbst_root != NULL)
  for (p = tree->rtbst_root; ; p = p->rtbst_link[dir])
    {
      int cmp = tree->rtbst_compare (item, p->rtbst_data, tree->rtbst_param);
      if (cmp == 0)
        return &p->rtbst_data;
      dir = cmp > 0;

      if (dir == 0)
        {
          if (p->rtbst_link[0] == NULL)
            break;
        }
      else /* dir == 1 */
        {
          if (p->rtbst_rtag == RTBST_THREAD)
            break;
        }
    }
else
  {
    p = (struct rtbst_node *) &tree->rtbst_root;
    dir = 0;
  }
   This code is included in *Note 377::.

   Now for the insertion code.  An insertion to the left of a node p in
a right-threaded tree replaces the left link by the new node n.  The
new node in turn has a null left child and a right thread pointing back
to p:

 [image src="rtbstins.png" text="                                         |
                             |           p
                             p       _.-' \\
                              \\  => n      a
                               a     \\
                                      [p]

" ]

An insertion to the right of p replaces the right thread by the new
child node n.  The new node has a null left child and a right thread
that points where p's right thread formerly pointed:

 [image src="rtbstins2.png" text="                                                 |
                                |                s
                                s     ____...---'
                       ___...--'     ...
                      ...               `_
                         `_       =>      p
                           p             / \\
                          / \\           a   n
                         a   [s]             \\
                                              [s]

" ]

We can handle both of these cases in one code segment.  The difference
is in the treatment of n's right child and p's right tag.  Insertion
into an empty tree is handled as a special case as well:

379. <Step 2: Insert new node into RTBST tree 379> =
n = tree->rtbst_alloc->libavl_malloc (tree->rtbst_alloc, sizeof *n);
if (n == NULL)
  return NULL;

tree->rtbst_count++;
n->rtbst_data = item;
n->rtbst_link[0] = NULL;
if (dir == 0)
  {
    if (tree->rtbst_root != NULL)
      n->rtbst_link[1] = p;
    else
      n->rtbst_link[1] = NULL;
  }
else /* dir == 1 */
  {
    p->rtbst_rtag = RTBST_CHILD;
    n->rtbst_link[1] = p->rtbst_link[1];
  }
n->rtbst_rtag = RTBST_THREAD;
p->rtbst_link[dir] = n;

return &n->rtbst_data;
   This code is included in *Note 377::.


File: libavl.info,  Node: Deleting from an RTBST,  Next: Traversing an RTBST,  Prev: Inserting into an RTBST,  Up: Right-Threaded Binary Search Trees

10.5 Deletion
=============

Deleting a node from an RTBST can be done using the same ideas as for
other kinds of trees we've seen.  However, as it turns out, a variant of
this usual technique allows for faster code.  In this section, we will
implement the usual method, then the improved version.  The latter is
actually used in libavl.

   Here is the outline of the function.  Step 2 is the only part that
varies between versions:

380. <RTBST item deletion function 380> =
void *
rtbst_delete (struct rtbst_table *tree, const void *item)
{
  struct rtbst_node *p;	/* Node to delete. */
  struct rtbst_node *q;	/* Parent of p. */
  int dir;              /* Index into q->rtbst_link[] that leads to p. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Find RTBST node to delete: 381.>
  <*Note Step 2: Delete RTBST node, left-looking: 388.>
  <*Note Step 3: Finish up after deleting RTBST node: 382.>
}
   This code is included in *Note 375::.

   The first step just finds the node to delete.  After it executes, p
is the node to delete and q and dir are set such that
q->rtbst_link[dir] == p.

381. <Step 1: Find RTBST node to delete 381> =
if (tree->rtbst_root == NULL)
  return NULL;

p = tree->rtbst_root;
q = (struct rtbst_node *) &tree->rtbst_root;
dir = 0;
if (p == NULL)
  return NULL;

for (;;)
  {
    int cmp = tree->rtbst_compare (item, p->rtbst_data, tree->rtbst_param);
    if (cmp == 0)
      break;

    dir = cmp > 0;
    if (dir == 0)
      {
        if (p->rtbst_link[0] == NULL)
          return NULL;
      }
    else /* dir == 1 */
      {
        if (p->rtbst_rtag == RTBST_THREAD)
          return NULL;
      }

    q = p;
    p = p->rtbst_link[dir];
  }
item = p->rtbst_data;
   This code is included in *Note 380::.

   The final step is also common.  We just clean up and return:

382. <Step 3: Finish up after deleting RTBST node 382> =
tree->rtbst_alloc->libavl_free (tree->rtbst_alloc, p);
tree->rtbst_count-;
return (void *) item;
   This code is included in *Note 380::.

* Menu:

* Right-Looking Deletion in a RTBST::
* Left-Looking Deletion in an RTBST::
* Comparing Deletion Algorithms::


File: libavl.info,  Node: Right-Looking Deletion in a RTBST,  Next: Left-Looking Deletion in an RTBST,  Prev: Deleting from an RTBST,  Up: Deleting from an RTBST

10.5.1 Right-Looking Deletion
-----------------------------

Our usual algorithm for deletion looks at the right subtree of the node
to be deleted, so we call it "right-looking."  The outline for this
kind of deletion is the same as in TBST deletion (*note Deleting from a
TBST::):

383. <Step 2: Delete RTBST node, right-looking 383> =
if (p->rtbst_rtag == RTBST_THREAD)
  {
    if (p->rtbst_link[0] != NULL)
      {
        <*Note Case 1 in right-looking RTBST deletion: 384.>
      }
    else
      {
        <*Note Case 2 in right-looking RTBST deletion: 385.>
      }
  }
else
  {
    struct rtbst_node *r = p->rtbst_link[1];
    if (r->rtbst_link[0] == NULL)
      {
        <*Note Case 3 in right-looking RTBST deletion: 386.>
      }
    else
      {
        <*Note Case 4 in right-looking RTBST deletion: 387.>
      }
  }

   Each of the four cases, presented below, is closely analogous to the
same case in TBST deletion.

Case 1: p has a right thread and a left child
.............................................

In this case, node p has a right thread and a left child.  As in a
TBST, this means that after deleting p we must update the right thread
in p's former left subtree to point to p's replacement.  The only
difference from <*Note Case 1 in TBST deletion: 260.> is in structure
members:

384. <Case 1 in right-looking RTBST deletion 384> =
struct rtbst_node *t = p->rtbst_link[0];
while (t->rtbst_rtag == RTBST_CHILD)
  t = t->rtbst_link[1];
t->rtbst_link[1] = p->rtbst_link[1];
q->rtbst_link[dir] = p->rtbst_link[0];
   This code is included in *Note 383::.

Case 2: p has a right thread and no left child
..............................................

If node p is a leaf, then there are two subcases, according to whether
p is a left child or a right child of its parent q.  If dir is 0, then
p is a left child and the pointer from its parent must be set to NULL.
If dir is 1, then p is a right child and the link from its parent must
be changed to a thread to its successor.

   In either of these cases we must set q->rtbst_link[dir]: if dir is
0, we set it to NULL, otherwise dir is 1 and we set it to
p->rtbst_link[1].  However, we know that p->rtbst_link[0] is NULL,
because p is a leaf, so we can instead unconditionally assign
p->rtbst_link[dir].  In addition, if dir is 1, then we must tag q's
right link as a thread.

   If q is the pseudo-root, then dir is 0 and everything works out fine
with no need for a special case.

385. <Case 2 in right-looking RTBST deletion 385> =
q->rtbst_link[dir] = p->rtbst_link[dir];
if (dir == 1)
  q->rtbst_rtag = RTBST_THREAD;
   This code is included in *Note 383::.

Case 3: p's right child has no left child
.........................................

Code for this case, where p has a right child r that itself has no left
child, is almost identical to <*Note Case 3 in TBST deletion: 262.>.
There is no left tag to copy, but it is still necessary to chase down
the right thread in r's new left subtree (the same as p's former left
subtree):

386. <Case 3 in right-looking RTBST deletion 386> =
r->rtbst_link[0] = p->rtbst_link[0];
if (r->rtbst_link[0] != NULL)
  {
    struct rtbst_node *t = r->rtbst_link[0];
    while (t->rtbst_rtag == RTBST_CHILD)
      t = t->rtbst_link[1];
    t->rtbst_link[1] = r;
  }
q->rtbst_link[dir] = r;
   This code is included in *Note 383::.

Case 4: p's right child has a left child
........................................

Code for case 4, the most general case, is very similar to <*Note Case
4 in TBST deletion: 263.>.  The only notable difference is in the
subcase where s has a right thread: in that case we just set r's left
link to NULL instead of having to set it up as a thread.

387. <Case 4 in right-looking RTBST deletion 387> =
struct rtbst_node *s;

for (;;)
  {
    s = r->rtbst_link[0];
    if (s->rtbst_link[0] == NULL)
      break;

    r = s;
  }

if (s->rtbst_rtag == RTBST_CHILD)
  r->rtbst_link[0] = s->rtbst_link[1];
else
  r->rtbst_link[0] = NULL;

s->rtbst_link[0] = p->rtbst_link[0];
if (p->rtbst_link[0] != NULL)
  {
    struct rtbst_node *t = p->rtbst_link[0];
    while (t->rtbst_rtag == RTBST_CHILD)
      t = t->rtbst_link[1];
    t->rtbst_link[1] = s;
  }

s->rtbst_link[1] = p->rtbst_link[1];
s->rtbst_rtag = RTBST_CHILD;

q->rtbst_link[dir] = s;
   This code is included in *Note 383::.

Exercises:

1. Rewrite <*Note Case 4 in right-looking RTBST deletion: 387.> to
replace the deleted node's rtavl_data by its successor, then delete the
successor, instead of shuffling pointers.  (Refer back to Exercise
4.8-3 for an explanation of why this approach cannot be used in libavl.)
[*Note answer: 10-5-1#1..]


File: libavl.info,  Node: Left-Looking Deletion in an RTBST,  Next: Comparing Deletion Algorithms,  Prev: Right-Looking Deletion in a RTBST,  Up: Deleting from an RTBST

10.5.2 Left-Looking Deletion
----------------------------

The previous section implemented the "right-looking" form of deletion
used elsewhere in libavl.  Compared to deletion in a fully threaded
binary tree, the benefits to using an RTBST with this kind of deletion
are minimal:

   * Cases 1 and 2 are similar code in both TBST and RTBST deletion.

   * Case 3 in an RTBST avoids one tag copy required in TBST deletion.

   * One subcase of case 4 in an RTBST avoids one tag assignment
     required in the same subcase of TBST deletion.

   This is hardly worth it.  We saved at most one assignment per call.
We need something better if it's ever going to be worthwhile to use
right-threaded trees.

   Fortunately, there is a way that we can save a little more.  This is
by changing our right-looking deletion into left-looking deletion, by
switching the use of left and right children in the algorithm.  In a
BST or TBST, this symmetrical change in the algorithm would have no
effect, because the BST and TBST node structures are themselves
symmetric.  But in an asymmetric RTBST even a symmetric change can have
a significant effect on an algorithm, as we'll see.

   The cases for left-looking deletion are outlined in the same way as
for right-looking deletion:

388. <Step 2: Delete RTBST node, left-looking 388> =
if (p->rtbst_link[0] == NULL)
  {
    if (p->rtbst_rtag == RTBST_CHILD)
      {
        <*Note Case 1 in left-looking RTBST deletion: 389.>
      }
    else
      {
        <*Note Case 2 in left-looking RTBST deletion: 390.>
      }
  }
else
  {
    struct rtbst_node *r = p->rtbst_link[0];
    if (r->rtbst_rtag == RTBST_THREAD)
      {
        <*Note Case 3 in left-looking RTBST deletion: 391.>
      }
    else
      {
        <*Note Case 4 in left-looking RTBST deletion: 392.>
      }
  }
   This code is included in *Note 380::.

Case 1: p has a right child but no left child
.............................................

If the node to delete p has a right child but no left child, we can
just replace it by its right child.  There is no right thread to update
in p's left subtree because p has no left child, and there is no left
thread to update because a right-threaded tree has no left threads.

   The deletion looks like this if p's right child is designated x:

 [image src="rtbstdel.png" text="                               |
                               p        |
                                \\       x
                                 x  =>  ^
                                 ^     a b
                                a b

" ]

389. <Case 1 in left-looking RTBST deletion 389> =
q->rtbst_link[dir] = p->rtbst_link[1];
This code is included in *Note 388::.

Case 2: p has a right thread and no left child
..............................................

This case is analogous to case 2 in right-looking deletion covered
earlier.  The same discussion applies.

390. <Case 2 in left-looking RTBST deletion 390> =
q->rtbst_link[dir] = p->rtbst_link[dir];
if (dir == 1)
  q->rtbst_rtag = RTBST_THREAD;
   This code is included in *Note 388::.

Case 3: p's left child has a right thread
.........................................

If p has a left child r that itself has a right thread, then we replace
p by r.  Node r receives p's former right link, as shown here:

 [image src="rtbstdel2.png" text="                                   |
                                   p       |
                               _.-' \\      r
                              r      b =>  ^
                             / \\          a b
                            a   [p]

" ]

There is no need to fiddle with threads.  If r has a right thread then
it gets replaced by p's right child or thread anyhow.  Any right thread
within r's left subtree either points within that subtree or to r.
Finally, r's right subtree cannot cause problems.

391. <Case 3 in left-looking RTBST deletion 391> =
r->rtbst_link[1] = p->rtbst_link[1];
r->rtbst_rtag = p->rtbst_rtag;
q->rtbst_link[dir] = r;
   This code is included in *Note 388::.

Case 4: p's left child has a right child
........................................

The final case handles deletion of a node p with a left child r that in
turn has a right child.  The code here follows the same pattern as
<*Note Case 4 in TBST deletion: 263.> (see the discussion there for
details).  The first step is to find the predecessor s of node p:

392. <Case 4 in left-looking RTBST deletion 392> =
struct rtbst_node *s;

for (;;)
  {
    s = r->rtbst_link[1];
    if (s->rtbst_rtag == RTBST_THREAD)
      break;

    r = s;
  }
   See also *Note 393:: and *Note 394::.
This code is included in *Note 388::.

   Next, we update r, handling two subcases depending on whether s has
a left child:

393. <Case 4 in left-looking RTBST deletion 392> +=
if (s->rtbst_link[0] != NULL)
  r->rtbst_link[1] = s->rtbst_link[0];
else
  {
    r->rtbst_link[1] = s;
    r->rtbst_rtag = RTBST_THREAD;
  }

   The final step is to copy p's fields into s, then set q's child
pointer to point to s instead of p.  There is no need to chase down any
threads.

394. <Case 4 in left-looking RTBST deletion 392> +=
s->rtbst_link[0] = p->rtbst_link[0];
s->rtbst_link[1] = p->rtbst_link[1];
s->rtbst_rtag = p->rtbst_rtag;

q->rtbst_link[dir] = s;

Exercises:

1. Rewrite <*Note Case 4 in left-looking RTBST deletion: 392.> to
replace the deleted node's rtavl_data by its predecessor, then delete
the predecessor, instead of shuffling pointers.  (Refer back to
Exercise 4.8-3 for an explanation of why this approach cannot be used
in libavl.)  [*Note answer: 10-5-2#1..]


File: libavl.info,  Node: Comparing Deletion Algorithms,  Prev: Left-Looking Deletion in an RTBST,  Up: Deleting from an RTBST

10.5.3 Aside: Comparison of Deletion Algorithms
-----------------------------------------------

This book has presented algorithms for deletion from BSTs, TBSTs, and
RTBSTs.  In fact, we implemented two algorithms for RTBSTs.  Each of
these four algorithms has slightly different performance
characteristics.  The following table summarizes the behavior of all of
the cases in these algorithms.  Each cell describes the actions that
take place: "link" is the number of link fields set, "tag" the number
of tag fields set, and "succ/pred" the number of general successor or
predecessors found during the case.

                 BST*           TBST           Right-Looking  Left-Looking
                                               TBST           TBST
                                                               
     Case 1      1 link         2 links        2 links        1 link
                                1 succ/pred    1 succ/pred    
                                                              
     Case 2      1 link         1 link         1 link         1 link
                                1 tag          1 tag          1 tag
                                                              
     Case 3      2 links        3 links        3 links        2 links
                                1 tag                         1 tag
                                1 succ/pred    1 succ/pred    
                                                              
     Case 4      4 links        5 links        5 links        4 links
     subcase 1                  2 tags         1 tag          1 tag
                 1 succ/pred    2 succ/pred    2 succ/pred    1 succ/pred
                                                              
     Case 4      4 links        5 links        5 links        4 links
     subcase 2                  2 tags         1 tag          1 tag
                 1 succ/pred    2 succ/pred    2 succ/pred    1 succ/pred
                                                              

     * Listed cases 1 and 2 both correspond to BST deletion case 1, and
     listed cases 3 and 4 to BST deletion cases 2 and 3, respectively.
     BST deletion does not have any subcases in its case 3 (listed case
     4), so it also saves a test to distinguish subcases.

   As you can see, the penalty for left-looking deletion from a RTBST,
compared to a plain BST, is at most one tag assignment in any given
case, except for the need to distinguish subcases of case 4.  In this
sense at least, left-looking deletion from an RTBST is considerably
faster than deletion from a TBST or right-looking deletion from a
RTBST.  This means that it can indeed be worthwhile to implement
right-threaded trees instead of BSTs or TBSTs.


File: libavl.info,  Node: Traversing an RTBST,  Next: Copying an RTBST,  Prev: Deleting from an RTBST,  Up: Right-Threaded Binary Search Trees

10.6 Traversal
==============

Traversal in an RTBST is unusual due to its asymmetry.  Moving from
smaller nodes to larger nodes is easy: we do it with the same algorithm
used in a TBST.  Moving the other way is more difficult and inefficient
besides: we have neither a stack of parent nodes to fall back on nor
left threads to short-circuit.

   RTBSTs use the same traversal structure as TBSTs, so we can reuse
some of the functions from TBST traversers.  We also get a few directly
from the implementations for BSTs.  Other than that, everything has to
be written anew here:

395. <RTBST traversal functions 395> =
<*Note TBST traverser null initializer; tbst => rtbst: 269.>
<*Note RTBST traverser first initializer: 396.>
<*Note RTBST traverser last initializer: 397.>
<*Note RTBST traverser search initializer: 398.>
<*Note TBST traverser insertion initializer; tbst => rtbst: 273.>
<*Note TBST traverser copy initializer; tbst => rtbst: 274.>
<*Note RTBST traverser advance function: 399.>
<*Note RTBST traverser back up function: 400.>
<*Note BST traverser current item function; bst => rtbst: 74.>
<*Note BST traverser replacement function; bst => rtbst: 75.>
   This code is included in *Note 375::, *Note 418::, and *Note 455::.

* Menu:

* RTBST Traverser First Initialization::
* RTBST Traverser Last Initialization::
* RTBST Traverser Find Initialization::
* RTBST Traverser Advancing::
* RTBST Traverser Retreating::


File: libavl.info,  Node: RTBST Traverser First Initialization,  Next: RTBST Traverser Last Initialization,  Prev: Traversing an RTBST,  Up: Traversing an RTBST

10.6.1 Starting at the First Node
---------------------------------

To find the first (least) item in the tree, we just descend all the way
to the left, as usual.  In an RTBST, as in a BST, this involves checking
for null pointers.

396. <RTBST traverser first initializer 396> =
void *
rtbst_t_first (struct rtbst_traverser *trav, struct rtbst_table *tree)
{
  assert (tree != NULL && trav != NULL);

  trav->rtbst_table = tree;
  trav->rtbst_node = tree->rtbst_root;
  if (trav->rtbst_node != NULL)
    {
      while (trav->rtbst_node->rtbst_link[0] != NULL)
        trav->rtbst_node = trav->rtbst_node->rtbst_link[0];
      return trav->rtbst_node->rtbst_data;
    }
  else
    return NULL;
}
   This code is included in *Note 395::.


File: libavl.info,  Node: RTBST Traverser Last Initialization,  Next: RTBST Traverser Find Initialization,  Prev: RTBST Traverser First Initialization,  Up: Traversing an RTBST

10.6.2 Starting at the Last Node
--------------------------------

To start at the last (greatest) item in the tree, we descend all the way
to the right.  In an RTBST, as in a TBST, this involves checking for
thread links.

397. <RTBST traverser last initializer 397> =
void *
rtbst_t_last (struct rtbst_traverser *trav, struct rtbst_table *tree)
{
  assert (tree != NULL && trav != NULL);

  trav->rtbst_table = tree;
  trav->rtbst_node = tree->rtbst_root;
  if (trav->rtbst_node != NULL)
    {
      while (trav->rtbst_node->rtbst_rtag == RTBST_CHILD)
        trav->rtbst_node = trav->rtbst_node->rtbst_link[1];
      return trav->rtbst_node->rtbst_data;
    }
  else
    return NULL;
}
   This code is included in *Note 395::.


File: libavl.info,  Node: RTBST Traverser Find Initialization,  Next: RTBST Traverser Advancing,  Prev: RTBST Traverser Last Initialization,  Up: Traversing an RTBST

10.6.3 Starting at a Found Node
-------------------------------

To start from an item found in the tree, we use the same algorithm as
rtbst_find().

398. <RTBST traverser search initializer 398> =
void *
rtbst_t_find (struct rtbst_traverser *trav, struct rtbst_table *tree,
              void *item)
{
  struct rtbst_node *p;

  assert (trav != NULL && tree != NULL && item != NULL);

  trav->rtbst_table = tree;
  trav->rtbst_node = NULL;

  p = tree->rtbst_root;
  if (p == NULL)
    return NULL;

  for (;;)
    {
      int cmp = tree->rtbst_compare (item, p->rtbst_data, tree->rtbst_param);
      if (cmp == 0)
        {
          trav->rtbst_node = p;
          return p->rtbst_data;
        }

      if (cmp < 0)
        {
          p = p->rtbst_link[0];
          if (p == NULL)
            return NULL;
        }
      else
        {
          if (p->rtbst_rtag == RTBST_THREAD)
            return NULL;
          p = p->rtbst_link[1];
        }
    }
}
   This code is included in *Note 395::.


File: libavl.info,  Node: RTBST Traverser Advancing,  Next: RTBST Traverser Retreating,  Prev: RTBST Traverser Find Initialization,  Up: Traversing an RTBST

10.6.4 Advancing to the Next Node
---------------------------------

We use the same algorithm to advance an RTBST traverser as for TBST
traversers.  The only important difference between this code and <*Note
TBST traverser advance function: 275.> is the substitution of
rtbst_rtag for tbst_tag[1].

399. <RTBST traverser advance function 399> =
void *
rtbst_t_next (struct rtbst_traverser *trav)
{
  assert (trav != NULL);

  if (trav->rtbst_node == NULL)
    return rtbst_t_first (trav, trav->rtbst_table);
  else if (trav->rtbst_node->rtbst_rtag == RTBST_THREAD)
    {
      trav->rtbst_node = trav->rtbst_node->rtbst_link[1];
      return trav->rtbst_node != NULL ? trav->rtbst_node->rtbst_data : NULL;
    }
  else
    {
      trav->rtbst_node = trav->rtbst_node->rtbst_link[1];
      while (trav->rtbst_node->rtbst_link[0] != NULL)
        trav->rtbst_node = trav->rtbst_node->rtbst_link[0];
      return trav->rtbst_node->rtbst_data;
    }
}
   This code is included in *Note 395::.


File: libavl.info,  Node: RTBST Traverser Retreating,  Prev: RTBST Traverser Advancing,  Up: Traversing an RTBST

10.6.5 Backing Up to the Previous Node
--------------------------------------

Moving an RTBST traverser backward has the same cases as in the other
ways of finding an inorder predecessor that we've already discussed.
The two main cases are distinguished on whether the current item has a
left child; the third case comes up when there is no current item,
implemented simply by delegation to rtbst_t_last():

400. <RTBST traverser back up function 400> =
void *
rtbst_t_prev (struct rtbst_traverser *trav)
{
  assert (trav != NULL);

  if (trav->rtbst_node == NULL)
    return rtbst_t_last (trav, trav->rtbst_table);
  else if (trav->rtbst_node->rtbst_link[0] == NULL)
    {
      <*Note Find predecessor of RTBST node with no left child: 401.>
    }
  else
    {
      <*Note Find predecessor of RTBST node with left child: 402.>
    }
}
   This code is included in *Note 395::.

   The novel case is where the node p whose predecessor we want has no
left child.  In this case, we use a modified version of the algorithm
originally specified for finding a node's successor in an unthreaded
tree (*note Better Iterative Traversal::).  We take the idea of moving
up until we've moved up to the left, and turn it upside down (to avoid
need for a parent stack) and reverse it (to find the predecessor
instead of the successor).

   The idea here is to trace p's entire direct ancestral line.  Starting
from the root of the tree, we repeatedly compare each node's data with
p's and use the result to move downward, until we encounter node p
itself.  Each time we move down from a node x to its right child, we
record x as the potential predecessor of p.  When we finally arrive at
p, the last node so selected is the actual predecessor, or if none was
selected then p is the least node in the tree and we select the null
item as its predecessor.

   Consider this algorithm in the context of the tree shown here:

 [image src="rtbstprev.png" text="                               3
                         __..-' `-----......______
                        1                         9
                    _.-' \\            ____....---' \\
                   0      2          5              []
                    \\      \\     _.-' `-.__
                     [1]    [3] 4          7
                                 \\     _.-' \\
                                  [5] 6      8
                                       \\      \\
                                        [7]    [9]

" ]

To find the predecessor of node 8, we trace the path from the root down
to it: 3-9-5-7-8.  The last time we move down to the right is from 7 to
8, so 7 is node 8's predecessor.  To find the predecessor of node 6, we
trace the path 3-9-5-7-6 and notice that we last move down to the right
from 5 to 7, so 5 is node 6's predecessor.  Finally, node 0 has the
null item as its predecessor because path 3-1-0 does not involve any
rightward movement.

   Here is the code to implement this case:

401. <Find predecessor of RTBST node with no left child 401> =
rtbst_comparison_func *cmp = trav->rtbst_table->rtbst_compare;
void *param = trav->rtbst_table->rtbst_param;
struct rtbst_node *node = trav->rtbst_node;
struct rtbst_node *i;

trav->rtbst_node = NULL;
for (i = trav->rtbst_table->rtbst_root; i != node; )
  {
    int dir = cmp (node->rtbst_data, i->rtbst_data, param) > 0;
    if (dir == 1)
      trav->rtbst_node = i;
    i = i->rtbst_link[dir];
  }

return trav->rtbst_node != NULL ? trav->rtbst_node->rtbst_data : NULL;
   This code is included in *Note 400::.

   The other case, where the node whose predecessor we want has a left
child, is nothing new.  We just find the largest node in the node's left
subtree:

402. <Find predecessor of RTBST node with left child 402> =
trav->rtbst_node = trav->rtbst_node->rtbst_link[0];
while (trav->rtbst_node->rtbst_rtag == RTBST_CHILD)
  trav->rtbst_node = trav->rtbst_node->rtbst_link[1];
return trav->rtbst_node->rtbst_data;
   This code is included in *Note 400::.


File: libavl.info,  Node: Copying an RTBST,  Next: Destroying an RTBST,  Prev: Traversing an RTBST,  Up: Right-Threaded Binary Search Trees

10.7 Copying
============

The algorithm that we used for copying a TBST makes use of threads, but
only right threads, so we can apply this algorithm essentially
unmodified to RTBSTs.

   We will make one change that superficially simplifies and improves
the elegance of the algorithm.  Function tbst_copy() in <*Note TBST
main copy function: 279.> uses a pair of local variables rp and rq to
store pointers to the original and new tree's root, because accessing
the tag field of a cast "pseudo-root" pointer produces undefined
behavior.  However, in an RTBST there is no tag for a node's left
subtree.  During a TBST copy, only the left tags of the root nodes are
accessed, so this means that we can use the pseudo-roots in the RTBST
copy, with no need for rp or rq.

403. <RTBST main copy function 403> =
struct rtbst_table *
rtbst_copy (const struct rtbst_table *org, rtbst_copy_func *copy,
            rtbst_item_func *destroy, struct libavl_allocator *allocator)
{
  struct rtbst_table *new;

  const struct rtbst_node *p;
  struct rtbst_node *q;

  assert (org != NULL);
  new = rtbst_create (org->rtbst_compare, org->rtbst_param,
                     allocator != NULL ? allocator : org->rtbst_alloc);
  if (new == NULL)
    return NULL;

  new->rtbst_count = org->rtbst_count;
  if (new->rtbst_count == 0)
    return new;

  p = (struct rtbst_node *) &org->rtbst_root;
  q = (struct rtbst_node *) &new->rtbst_root;
  for (;;)
    {
      if (p->rtbst_link[0] != NULL)
        {
          if (!copy_node (new, q, 0, p->rtbst_link[0], copy))
            {
              copy_error_recovery (new, destroy);
              return NULL;
            }

          p = p->rtbst_link[0];
          q = q->rtbst_link[0];
        }
      else
        {
          while (p->rtbst_rtag == RTBST_THREAD)
            {
              p = p->rtbst_link[1];
              if (p == NULL)
                {
                  q->rtbst_link[1] = NULL;
                  return new;
                }

              q = q->rtbst_link[1];
            }

          p = p->rtbst_link[1];
          q = q->rtbst_link[1];
        }

      if (p->rtbst_rtag == RTBST_CHILD)
        if (!copy_node (new, q, 1, p->rtbst_link[1], copy))
          {
            copy_error_recovery (new, destroy);
            return NULL;
          }
    }
}
   This code is included in *Note 406:: and *Note 447::.

   The code to copy a node must be modified to deal with the
asymmetrical nature of insertion in an RTBST:

404. <RTBST node copy function 404> =
static int
copy_node (struct rtbst_table *tree,
           struct rtbst_node *dst, int dir,
           const struct rtbst_node *src, rtbst_copy_func *copy)
{
  struct rtbst_node *new =
    tree->rtbst_alloc->libavl_malloc (tree->rtbst_alloc, sizeof *new);
  if (new == NULL)
    return 0;

  new->rtbst_link[0] = NULL;
  new->rtbst_rtag = RTBST_THREAD;
  if (dir == 0)
    new->rtbst_link[1] = dst;
  else
    {
      new->rtbst_link[1] = dst->rtbst_link[1];
      dst->rtbst_rtag = RTBST_CHILD;
    }
  dst->rtbst_link[dir] = new;

  if (copy == NULL)
    new->rtbst_data = src->rtbst_data;
  else
    {
      new->rtbst_data = copy (src->rtbst_data, tree->rtbst_param);
      if (new->rtbst_data == NULL)
        return 0;
    }

  return 1;
}
   This code is included in *Note 406::.

   The error recovery function for copying is a bit simpler now, because
the use of the pseudo-root means that no assignment to the new tree's
root need take place, eliminating the need for one of the function's
parameters:

405. <RTBST copy error helper function 405> =
static void
copy_error_recovery (struct rtbst_table *new, rtbst_item_func *destroy)
{
  struct rtbst_node *p = new->rtbst_root;
  if (p != NULL)
    {
      while (p->rtbst_rtag == RTBST_CHILD)
        p = p->rtbst_link[1];
      p->rtbst_link[1] = NULL;
    }
  rtbst_destroy (new, destroy);
}
   This code is included in *Note 406:: and *Note 447::.

406. <RTBST copy function 406> =
<*Note RTBST node copy function: 404.>
<*Note RTBST copy error helper function: 405.>
<*Note RTBST main copy function: 403.>
   This code is included in *Note 375::.


File: libavl.info,  Node: Destroying an RTBST,  Next: Balancing an RTBST,  Prev: Copying an RTBST,  Up: Right-Threaded Binary Search Trees

10.8 Destruction
================

The destruction algorithm for TBSTs makes use only of right threads, so
we can easily adapt it for RTBSTs.

407. <RTBST destruction function 407> =
void
rtbst_destroy (struct rtbst_table *tree, rtbst_item_func *destroy)
{
  struct rtbst_node *p; /* Current node. */
  struct rtbst_node *n; /* Next node. */

  p = tree->rtbst_root;
  if (p != NULL)
    while (p->rtbst_link[0] != NULL)
      p = p->rtbst_link[0];

  while (p != NULL)
    {
      n = p->rtbst_link[1];
      if (p->rtbst_rtag == RTBST_CHILD)
        while (n->rtbst_link[0] != NULL)
          n = n->rtbst_link[0];

      if (destroy != NULL && p->rtbst_data != NULL)
        destroy (p->rtbst_data, tree->rtbst_param);
      tree->rtbst_alloc->libavl_free (tree->rtbst_alloc, p);

      p = n;
    }

  tree->rtbst_alloc->libavl_free (tree->rtbst_alloc, tree);
}
   This code is included in *Note 375::, *Note 418::, and *Note 455::.


File: libavl.info,  Node: Balancing an RTBST,  Next: Testing RTBSTs,  Prev: Destroying an RTBST,  Up: Right-Threaded Binary Search Trees

10.9 Balance
============

As for so many other operations, we can reuse most of the TBST balancing
code to rebalance RTBSTs.  Some of the helper functions can be
completely recycled:

408. <RTBST balance function 408> =
<*Note RTBST tree-to-vine function: 409.>
<*Note RTBST vine compression function: 410.>
<*Note TBST vine-to-tree function; tbst => rtbst: 285.>
<*Note TBST main balance function; tbst => rtbst: 283.>
   This code is included in *Note 375::.

   The only substantative difference for the remaining two functions is
that there is no need to set nodes' left tags (since they don't have
any):

409. <RTBST tree-to-vine function 409> =
static void
tree_to_vine (struct rtbst_table *tree)
{
  struct rtbst_node *p;

  if (tree->rtbst_root == NULL)
    return;

  p = tree->rtbst_root;
  while (p->rtbst_link[0] != NULL)
    p = p->rtbst_link[0];

  for (;;)
    {
      struct rtbst_node *q = p->rtbst_link[1];
      if (p->rtbst_rtag == RTBST_CHILD)
        {
          while (q->rtbst_link[0] != NULL)
            q = q->rtbst_link[0];
          p->rtbst_rtag = RTBST_THREAD;
          p->rtbst_link[1] = q;
        }

      if (q == NULL)
        break;

      q->rtbst_link[0] = p;
      p = q;
    }

  tree->rtbst_root = p;
}
   This code is included in *Note 408::.

410. <RTBST vine compression function 410> =
/* Performs a compression transformation count times,
   starting at root. */
static void
compress (struct rtbst_node *root,
          unsigned long nonthread, unsigned long thread)
{
  assert (root != NULL);

  while (nonthread-)
    {
      struct rtbst_node *red = root->rtbst_link[0];
      struct rtbst_node *black = red->rtbst_link[0];

      root->rtbst_link[0] = black;
      red->rtbst_link[0] = black->rtbst_link[1];
      black->rtbst_link[1] = red;
      root = black;
    }

  while (thread-)
    {
      struct rtbst_node *red = root->rtbst_link[0];
      struct rtbst_node *black = red->rtbst_link[0];

      root->rtbst_link[0] = black;
      red->rtbst_link[0] = NULL;
      black->rtbst_rtag = RTBST_CHILD;
      root = black;
    }
}
   This code is included in *Note 408::.


File: libavl.info,  Node: Testing RTBSTs,  Prev: Balancing an RTBST,  Up: Right-Threaded Binary Search Trees

10.10 Testing
=============

There's nothing new or interesting in the test code.

411. <rtbst-test.c 411> =
<*Note License: 1.>
#include <assert.h>
#include <limits.h>
#include <stdio.h>
#include "rtbst.h"
#include "test.h"

<*Note RTBST print function: 412.>
<*Note BST traverser check function; bst => rtbst: 104.>
<*Note Compare two RTBSTs for structure and content: 413.>
<*Note Recursively verify RTBST structure: 414.>
<*Note BST verify function; bst => rtbst: 109.>
<*Note TBST test function; tbst => rtbst: 295.>
<*Note BST overflow test function; bst => rtbst: 122.>

412. <RTBST print function 412> =
void
print_tree_structure (struct rtbst_node *node, int level)
{
  if (level > 16)
    {
      printf ("[...]");
      return;
    }

  if (node == NULL)
    {
      printf ("<nil>");
      return;
    }

  printf ("%d(", node->rtbst_data ? *(int *) node->rtbst_data : -1);

  if (node->rtbst_link[0] != NULL)
    print_tree_structure (node->rtbst_link[0], level + 1);

  fputs (", ", stdout);

  if (node->rtbst_rtag == RTBST_CHILD)
    {
      if (node->rtbst_link[1] == node)
        printf ("loop");
      else
        print_tree_structure (node->rtbst_link[1], level + 1);
    }
  else if (node->rtbst_link[1] != NULL)
    printf (">%d",
            (node->rtbst_link[1]->rtbst_data
             ? *(int *) node->rtbst_link[1]->rtbst_data : -1));
  else
    printf (">>");

  putchar (')');
}

void
print_whole_tree (const struct rtbst_table *tree, const char *title)
{
  printf ("%s: ", title);
  print_tree_structure (tree->rtbst_root, 0);
  putchar ('\n');
}
   This code is included in *Note 411::, *Note 449::, and *Note 482::.

413. <Compare two RTBSTs for structure and content 413> =
static int
compare_trees (struct rtbst_node *a, struct rtbst_node *b)
{
  int okay;

  if (a == NULL || b == NULL)
    {
      if (a != NULL || b != NULL)
        {
          printf (" a=%d b=%d\n",
                  a ? *(int *) a->rtbst_data : -1,
                  b ? *(int *) b->rtbst_data : -1);
          assert (0);
        }
      return 1;
    }
  assert (a != b);

  if (*(int *) a->rtbst_data != *(int *) b->rtbst_data
      || a->rtbst_rtag != b->rtbst_rtag)
    {
      printf (" Copied nodes differ: a=%d b=%d a:",
              *(int *) a->rtbst_data, *(int *) b->rtbst_data);

      if (a->rtbst_rtag == RTBST_CHILD)
        printf ("r");

      printf (" b:");
      if (b->rtbst_rtag == RTBST_CHILD)
        printf ("r");

      printf ("\n");
      return 0;
    }

  if (a->rtbst_rtag == RTBST_THREAD)
    assert ((a->rtbst_link[1] == NULL)
            != (a->rtbst_link[1] != b->rtbst_link[1]));

  okay = compare_trees (a->rtbst_link[0], b->rtbst_link[0]);
  if (a->rtbst_rtag == RTBST_CHILD)
    okay &= compare_trees (a->rtbst_link[1], b->rtbst_link[1]);
  return okay;
}
   This code is included in *Note 411::.

414. <Recursively verify RTBST structure 414> =
static void
recurse_verify_tree (struct rtbst_node *node, int *okay, size_t *count,
                     int min, int max)
{
  int d;                /* Value of this node's data. */
  size_t subcount[2];   /* Number of nodes in subtrees. */

  if (node == NULL)
    {
      *count = 0;
      return;
    }
  d = *(int *) node->rtbst_data;

  <*Note Verify binary search tree ordering: 114.>

  subcount[0] = subcount[1] = 0;
  recurse_verify_tree (node->rtbst_link[0], okay, &subcount[0], min, d - 1);
  if (node->rtbst_rtag == RTBST_CHILD)
    recurse_verify_tree (node->rtbst_link[1], okay, &subcount[1], d + 1, max);
  *count = 1 + subcount[0] + subcount[1];
}
   This code is included in *Note 411::.


File: libavl.info,  Node: Right-Threaded AVL Trees,  Next: Right-Threaded Red-Black Trees,  Prev: Right-Threaded Binary Search Trees,  Up: Top

11 Right-Threaded AVL Trees
***************************

In the same way that we can combine threaded trees with AVL trees to
produce threaded AVL trees, we can combine right-threaded trees with
AVL trees to produce right-threaded AVL trees.  This chapter explores
this combination, producing another table implementation.

   Here's the form of the source and header files.  Notice the use of
rtavl_ as the identifier prefix.  Likewise, we will often refer to
right-threaded AVL trees as "RTAVL trees".

415. <rtavl.h 415> =
<*Note License: 1.>
#ifndef RTAVL_H
#define RTAVL_H 1

#include <stddef.h>

<*Note Table types; tbl => rtavl: 14.>
<*Note BST maximum height; bst => rtavl: 28.>
<*Note TBST table structure; tbst => rtavl: 250.>
<*Note RTAVL node structure: 417.>
<*Note TBST traverser structure; tbst => rtavl: 267.>
<*Note Table function prototypes; tbl => rtavl: 15.>

#endif /* rtavl.h */

416. <rtavl.c 416> =
<*Note License: 1.>
#include <assert.h>
#include <stdio.h>
#include <stdlib.h>
#include "rtavl.h"

<*Note RTAVL functions: 418.>

* Menu:

* RTAVL Data Types::
* RTAVL Operations::
* RTBST Rotations::
* Inserting into an RTAVL Tree::
* Deleting from an RTAVL Tree::
* Copying an RTAVL Tree::
* Testing RTAVL Trees::


File: libavl.info,  Node: RTAVL Data Types,  Next: RTAVL Operations,  Prev: Right-Threaded AVL Trees,  Up: Right-Threaded AVL Trees

11.1 Data Types
===============

Besides the members needed for any BST, an RTAVL node structure needs a
tag to indicate whether the right link is a child pointer or a thread,
and a balance factor to facilitate AVL balancing.  Here's what we end up
with:

417. <RTAVL node structure 417> =
/* Characterizes a link as a child pointer or a thread. */
enum rtavl_tag
  {
    RTAVL_CHILD,                     /* Child pointer. */
    RTAVL_THREAD                     /* Thread. */
  };

/* A threaded binary search tree node. */
struct rtavl_node
  {
    struct rtavl_node *rtavl_link[2]; /* Subtrees. */
    void *rtavl_data;                 /* Pointer to data. */
    unsigned char rtavl_rtag;         /* Tag field. */
    signed char rtavl_balance;        /* Balance factor. */
  };
   This code is included in *Note 415::.


File: libavl.info,  Node: RTAVL Operations,  Next: RTBST Rotations,  Prev: RTAVL Data Types,  Up: Right-Threaded AVL Trees

11.2 Operations
===============

Most of the operations for RTAVL trees can come directly from their
RTBST implementations.  The notable exceptions are, as usual, the
insertion and deletion functions.  The copy function will also need a
small tweak.  Here's the list of operations:

418. <RTAVL functions 418> =
<*Note TBST creation function; tbst => rtavl: 252.>
<*Note RTBST search function; rtbst => rtavl: 376.>
<*Note RTAVL item insertion function: 419.>
<*Note Table insertion convenience functions; tbl => rtavl: 592.>
<*Note RTAVL item deletion function: 429.>
<*Note RTBST traversal functions; rtbst => rtavl: 395.>
<*Note RTAVL copy function: 447.>
<*Note RTBST destruction function; rtbst => rtavl: 407.>
<*Note Default memory allocation functions; tbl => rtavl: 6.>
<*Note Table assertion functions; tbl => rtavl: 594.>
   This code is included in *Note 416::.


File: libavl.info,  Node: RTBST Rotations,  Next: Inserting into an RTAVL Tree,  Prev: RTAVL Operations,  Up: Right-Threaded AVL Trees

11.3 Rotations
==============

We will use rotations in right-threaded trees in the same way as for
other kinds of trees that we have already examined.  As always, a
generic rotation looks like this:

 [image src="rotation.png" text="                               |        |
                               Y        X
                              / \\      / \\
                             X   c    a   Y
                             ^            ^
                            a b          b c

" ]

On the left side of this diagram, a may be an empty subtree and b and c
may be threads.  On the right side, a and b may be empty subtrees and c
may be a thread.  If none of them in fact represent actual nodes, then
we end up with the following pathological case:

 [image src="rtavlrot.png" text="                                |       |
                                Y       X
                            _.-' \\       \\
                           X      []      Y
                            \\              \\
                             [Y]            []

" ]

Notice the asymmetry here: in a right rotation the right thread from X
to Y becomes a null left child of Y, but in a left rotation this is
reversed and a null subtree b becomes a right thread from X to Y.
Contrast this to the correponding rotation in a threaded tree (*note
TBST Rotations::), where either way the same kind of change occurs: the
thread from X to Y, or vice versa, simply reverses direction.

   As with other kinds of rotations we've seen, there is no need to make
any changes in subtrees of a, b, or c, because of rotations' locality
and order-preserving properties (*note BST Rotations::).  In
particular, nodes a and c, if they exist, need no adjustments, as
implied by the diagram above, which shows no changes to these subtrees
on opposite sides.

Exercises:

1. Write functions for right and left rotations in right-threaded BSTs,
analogous to those for unthreaded BSTs developed in Exercise 4.3-2.
[*Note answer: 11-3#1..]


File: libavl.info,  Node: Inserting into an RTAVL Tree,  Next: Deleting from an RTAVL Tree,  Prev: RTBST Rotations,  Up: Right-Threaded AVL Trees

11.4 Insertion
==============

Insertion into an RTAVL tree follows the same pattern as insertion into
other kinds of balanced tree.  The outline is straightforward:

419. <RTAVL item insertion function 419> =
void **
rtavl_probe (struct rtavl_table *tree, void *item)
{
  <*Note avl_probe() local variables; avl => rtavl: 147.>

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search RTAVL tree for insertion point: 420.>
  <*Note Step 2: Insert RTAVL node: 421.>
  <*Note Step 3: Update balance factors after AVL insertion; avl => rtavl: 150.>
  <*Note Step 4: Rebalance after RTAVL insertion: 422.>
}
   This code is included in *Note 418::.

* Menu:

* Steps 1-1 in RTAVL Insertion::
* Rebalancing RTAVL Trees::


File: libavl.info,  Node: Steps 1-1 in RTAVL Insertion,  Next: Rebalancing RTAVL Trees,  Prev: Inserting into an RTAVL Tree,  Up: Inserting into an RTAVL Tree

11.4.1 Steps 1-2: Search and Insert
-----------------------------------

The basic insertion step itself follows the same steps as <*Note RTBST
item insertion function: 377.> does for a plain RTBST.  We do keep
track of the directions moved on stack da[] and the last-seen node with
nonzero balance factor, in the same way as <*Note Step 1: Search AVL
tree for insertion point: 148.> for unthreaded AVL trees.

420. <Step 1: Search RTAVL tree for insertion point 420> =
z = (struct rtavl_node *) &tree->rtavl_root;
y = tree->rtavl_root;
if (tree->rtavl_root != NULL)
  for (q = z, p = y; ; q = p, p = p->rtavl_link[dir])
    {
      int cmp = tree->rtavl_compare (item, p->rtavl_data, tree->rtavl_param);
      if (cmp == 0)
        return &p->rtavl_data;

      if (p->rtavl_balance != 0)
        z = q, y = p, k = 0;
      da[k++] = dir = cmp > 0;

      if (dir == 0)
        {
          if (p->rtavl_link[0] == NULL)
            break;
        }
      else /* dir == 1 */
        {
          if (p->rtavl_rtag == RTAVL_THREAD)
            break;
        }
    }
else
  {
    p = (struct rtavl_node *) &tree->rtavl_root;
    dir = 0;
  }
   This code is included in *Note 419::.

421. <Step 2: Insert RTAVL node 421> =
n = tree->rtavl_alloc->libavl_malloc (tree->rtavl_alloc, sizeof *n);
if (n == NULL)
  return NULL;

tree->rtavl_count++;
n->rtavl_data = item;
n->rtavl_link[0] = NULL;
if (dir == 0)
  n->rtavl_link[1] = p;
else /* dir == 1 */
  {
    p->rtavl_rtag = RTAVL_CHILD;
    n->rtavl_link[1] = p->rtavl_link[1];
  }
n->rtavl_rtag = RTAVL_THREAD;
n->rtavl_balance = 0;
p->rtavl_link[dir] = n;
if (y == NULL)
  {
    n->rtavl_link[1] = NULL;
    return &n->rtavl_data;
  }
   This code is included in *Note 419::.


File: libavl.info,  Node: Rebalancing RTAVL Trees,  Prev: Steps 1-1 in RTAVL Insertion,  Up: Inserting into an RTAVL Tree

11.4.2 Step 4: Rebalance
------------------------

Unlike all of the AVL rebalancing algorithms we've seen so far,
rebalancing of a right-threaded AVL tree is not symmetric.  This means
that we cannot single out left-side rebalancing or right-side
rebalancing as we did before, hand-waving the rest of it as a symmetric
case.  But both cases are very similar, if not exactly symmetric, so we
will present the corresponding cases together.  The theory is exactly
the same as before (*note Rebalancing AVL Trees::).  Here is the code
to choose between left-side and right-side rebalancing:

422. <Step 4: Rebalance after RTAVL insertion 422> =
if (y->rtavl_balance == -2)
  {
    <*Note Step 4: Rebalance RTAVL tree after insertion to left: 423.>
  }
else if (y->rtavl_balance == +2)
  {
    <*Note Step 4: Rebalance RTAVL tree after insertion to right: 424.>
  }
else
  return &n->rtavl_data;

z->rtavl_link[y != z->rtavl_link[0]] = w;
return &n->rtavl_data;
   This code is included in *Note 419::.

   The code to choose between the two subcases within the left-side and
right-side rebalancing cases follows below.  As usual during
rebalancing, y is the node at which rebalancing occurs, x is its child
on the same side as the inserted node, and cases are distinguished on
the basis of x's balance factor:

423. <Step 4: Rebalance RTAVL tree after insertion to left 423> =
struct rtavl_node *x = y->rtavl_link[0];
if (x->rtavl_balance == -1)
  {
    <*Note Rebalance for - balance factor in RTAVL insertion in left subtree: 425.>
  }
else
  {
    <*Note Rebalance for + balance factor in RTAVL insertion in left subtree: 427.>
  }
   This code is included in *Note 422::.

424. <Step 4: Rebalance RTAVL tree after insertion to right 424> =
struct rtavl_node *x = y->rtavl_link[1];
if (x->rtavl_balance == +1)
  {
    <*Note Rebalance for + balance factor in RTAVL insertion in right subtree: 426.>
  }
else
  {
    <*Note Rebalance for - balance factor in RTAVL insertion in right subtree: 428.>
  }
   This code is included in *Note 422::.

Case 1: x has taller subtree on side of insertion
.................................................

If node x's taller subtree is on the same side as the inserted node,
then we perform a rotation at y in the opposite direction.  That is, if
the insertion occurred in the left subtree of y and x has a - balance
factor, we rotate right at y, and if the insertion was to the right and
x has a + balance factor, we rotate left at y.  This changes the
balance of both x and y to zero.  None of this is a change from
unthreaded or fully threaded rebalancing.  The difference is in the
handling of empty subtrees, that is, in the rotation itself (*note
RTBST Rotations::).

   Here is a diagram of left-side rebalancing for the interesting case
where x has a right thread.  Taken along with x's - balance factor,
this means that n, the newly inserted node, must be x's left child.
Therefore, subtree x has height 2, so y has no right child (because it
has a -2 balance factor).  This chain of logic means that we know
exactly what the tree looks like in this particular subcase:

 [image src="rtavlins1.png" text="                               |
                               y                |
                             <-->               x
                       __..-'    \\             <0>
                       x          []     __..-'   \\
                      <->            =>  n          y
                __..-'   \\              <0>        <0>
                n         [y]              \\          \\
               <0>                          [x]        []
                  \\
                   [x]

" ]

425. <Rebalance for - balance factor in RTAVL insertion in left subtree 425> =
w = x;
if (x->rtavl_rtag == RTAVL_THREAD)
  {
    x->rtavl_rtag = RTAVL_CHILD;
    y->rtavl_link[0] = NULL;
  }
else
  y->rtavl_link[0] = x->rtavl_link[1];
x->rtavl_link[1] = y;
x->rtavl_balance = y->rtavl_balance = 0;
This code is included in *Note 423::.

   Here is the diagram and code for the similar right-side case:

 [image src="rtavlins2.png" text="                    |
                    y                        |
                  <++>                       x
                      \\                     <0>
                        x             __..-'   \\
                       <+>        =>  y          n
                          \\          <0>        <0>
                            n           \\          \\
                           <0>           [x]        []
                              \\
                               []

" ]

426. <Rebalance for + balance factor in RTAVL insertion in right subtree 426> =
w = x;
if (x->rtavl_link[0] == NULL)
  {
    y->rtavl_rtag = RTAVL_THREAD;
    y->rtavl_link[1] = x;
  }
else
  y->rtavl_link[1] = x->rtavl_link[0];
x->rtavl_link[0] = y;
x->rtavl_balance = y->rtavl_balance = 0;
This code is included in *Note 424::.

Case 2: x has taller subtree on side opposite insertion
.......................................................

If node x's taller subtree is on the side opposite the newly inserted
node, then we perform a double rotation: first rotate at x in the same
direction as the inserted node, then in the opposite direction at y.
This is the same as in a threaded or unthreaded tree, and indeed we can
reuse much of the code.

   The case where the details differ is, as usual, where threads or null
child pointers are moved around.  In the most extreme case for insertion
to the left, where w is a leaf, we know that x has no left child and s
no right child, and the situation looks like the diagram below before
and after the rebalancing step:

 [image src="rtavlins3.png" text="                              |
                              y                |
                            <-->               w
                  ___...---'    \\             <0>
                  x              []     __..-'   \\
                 <+>                =>  x          y
                    \\                  <0>        <0>
                      w                   \\          \\
                     <0>                   [w]        []
                        \\
                         [y]

" ]

427. <Rebalance for + balance factor in RTAVL insertion in left subtree 427> =
<*Note Rotate left at x then right at y in AVL tree; avl => rtavl: 156.>
if (x->rtavl_link[1] == NULL)
  {
    x->rtavl_rtag = RTAVL_THREAD;
    x->rtavl_link[1] = w;
  }
if (w->rtavl_rtag == RTAVL_THREAD)
  {
    y->rtavl_link[0] = NULL;
    w->rtavl_rtag = RTAVL_CHILD;
  }
This code is included in *Note 423:: and *Note 442::.

   Here is the code and diagram for right-side insertion rebalancing:

 [image src="rtavlins4.png" text="                   |
                   y                          |
                 <++>                         w
                     `--..__                 <0>
                             x         __..-'   \\
                            <->    =>  y          x
                      __..-'   \\      <0>        <0>
                      w         []       \\          \\
                     <0>                  [w]        []
                        \\
                         [x]

" ]

428. <Rebalance for - balance factor in RTAVL insertion in right subtree 428> =
<*Note Rotate right at x then left at y in AVL tree; avl => rtavl: 159.>
if (y->rtavl_link[1] == NULL)
  {
    y->rtavl_rtag = RTAVL_THREAD;
    y->rtavl_link[1] = w;
  }
if (w->rtavl_rtag == RTAVL_THREAD)
  {
    x->rtavl_link[0] = NULL;
    w->rtavl_rtag = RTAVL_CHILD;
  }
This code is included in *Note 424:: and *Note 441::.


File: libavl.info,  Node: Deleting from an RTAVL Tree,  Next: Copying an RTAVL Tree,  Prev: Inserting into an RTAVL Tree,  Up: Right-Threaded AVL Trees

11.5 Deletion
=============

Deletion in an RTAVL tree takes the usual pattern.

429. <RTAVL item deletion function 429> =
void *
rtavl_delete (struct rtavl_table *tree, const void *item)
{
  /* Stack of nodes. */
  struct rtavl_node *pa[RTAVL_MAX_HEIGHT]; /* Nodes. */
  unsigned char da[RTAVL_MAX_HEIGHT];     /* rtavl_link[] indexes. */
  int k;                                  /* Stack pointer. */

  struct rtavl_node *p; /* Traverses tree to find node to delete. */

  assert (tree != NULL && item != NULL);

  <*Note Step 1: Search RTAVL tree for item to delete: 430.>
  <*Note Step 2: Delete RTAVL node: 431.>
  <*Note Steps 3 and 4: Update balance factors and rebalance after RTAVL deletion: 438.>

  return (void *) item;
}
   This code is included in *Note 418::.

* Menu:

* Deleting a RTAVL Node Step 1 - Search::
* Deleting a RTAVL Node Step 2 - Delete::
* Deleting a RTAVL Node Step 3 - Update::
* Deleting a RTAVL Node Step 4 - Rebalance::


File: libavl.info,  Node: Deleting a RTAVL Node Step 1 - Search,  Next: Deleting a RTAVL Node Step 2 - Delete,  Prev: Deleting from an RTAVL Tree,  Up: Deleting from an RTAVL Tree

11.5.1 Step 1: Search
---------------------

There's nothing new in searching an RTAVL tree for a node to delete.  We
use p to search the tree, and push its chain of parent nodes onto stack
pa[] along with the directions da[] moved down from them, including the
pseudo-root node at the top.

430. <Step 1: Search RTAVL tree for item to delete 430> =
k = 1;
da[0] = 0;
pa[0] = (struct rtavl_node *) &tree->rtavl_root;
p = tree->rtavl_root;
if (p == NULL)
  return NULL;

for (;;)
  {
    int cmp, dir;

    cmp = tree->rtavl_compare (item, p->rtavl_data, tree->rtavl_param);
    if (cmp == 0)
      break;

    dir = cmp > 0;
    if (dir == 0)
      {
        if (p->rtavl_link[0] == NULL)
          return NULL;
      }
    else /* dir == 1 */
      {
        if (p->rtavl_rtag == RTAVL_THREAD)
          return NULL;
      }

    pa[k] = p;
    da[k++] = dir;
    p = p->rtavl_link[dir];
  }
tree->rtavl_count-;
item = p->rtavl_data;
   This code is included in *Note 429:: and *Note 468::.


File: libavl.info,  Node: Deleting a RTAVL Node Step 2 - Delete,  Next: Deleting a RTAVL Node Step 3 - Update,  Prev: Deleting a RTAVL Node Step 1 - Search,  Up: Deleting from an RTAVL Tree

11.5.2 Step 2: Delete
---------------------

As demonstrated in the previous chapter, left-looking deletion, where we
examine the left subtree of the node to be deleted, is more efficient
than right-looking deletion in an RTBST (*note Left-Looking Deletion in
an RTBST::).  This holds true in an RTAVL tree, too.

431. <Step 2: Delete RTAVL node 431> =
if (p->rtavl_link[0] == NULL)
  {
    if (p->rtavl_rtag == RTAVL_CHILD)
      {
        <*Note Case 1 in RTAVL deletion: 432.>
      }
    else
      {
        <*Note Case 2 in RTAVL deletion: 433.>
      }
  }
else
  {
    struct rtavl_node *r = p->rtavl_link[0];
    if (r->rtavl_rtag == RTAVL_THREAD)
      {
        <*Note Case 3 in RTAVL deletion: 434.>
      }
    else
      {
        <*Note Case 4 in RTAVL deletion: 435.>
      }
  }

tree->rtavl_alloc->libavl_free (tree->rtavl_alloc, p);
   This code is included in *Note 429::.

Case 1: p has a right child but no left child
.............................................

If the node to be deleted, p, has a right child but not a left child,
then we replace it by its right child.

432. <Case 1 in RTAVL deletion 432> =
pa[k - 1]->rtavl_link[da[k - 1]] = p->rtavl_link[1];
   This code is included in *Note 431:: and *Note 470::.

Case 2: p has a right thread and no left child
..............................................

If we are deleting a leaf, then we replace it by a null pointer if it's
a left child, or by a pointer to its own former right thread if it's a
right child.  Refer back to the commentary on <*Note Case 2 in
right-looking RTBST deletion: 385.> for further explanation.

433. <Case 2 in RTAVL deletion 433> =
pa[k - 1]->rtavl_link[da[k - 1]] = p->rtavl_link[da[k - 1]];
if (da[k - 1] == 1)
  pa[k - 1]->rtavl_rtag = RTAVL_THREAD;
   This code is included in *Note 431:: and *Note 471::.

Case 3: p's left child has a right thread
.........................................

If p has a left child r, and r has a right thread, then we replace p by
r and transfer p's former right link to r.  Node r also receives p's
balance factor.

434. <Case 3 in RTAVL deletion 434> =
r->rtavl_link[1] = p->rtavl_link[1];
r->rtavl_rtag = p->rtavl_rtag;
r->rtavl_balance = p->rtavl_balance;
pa[k - 1]->rtavl_link[da[k - 1]] = r;
da[k] = 0;
pa[k++] = r;
   This code is included in *Note 431::.

Case 4: p's left child has a right child
........................................

The final case, where node p's left child r has a right child, is also
the most complicated.  We find p's predecessor s first:

435. <Case 4 in RTAVL deletion 435> =
struct rtavl_node *s;
int j = k++;

for (;;)
  {
    da[k] = 1;
    pa[k++] = r;
    s = r->rtavl_link[1];
    if (s->rtavl_rtag == RTAVL_THREAD)
      break;

    r = s;
  }
   See also *Note 436:: and *Note 437::.
This code is included in *Note 431::.

   Then we move s into p's place, not forgetting to update links and
tags as necessary:

436. <Case 4 in RTAVL deletion 435> +=
da[j] = 0;
pa[j] = pa[j - 1]->rtavl_link[da[j - 1]] = s;

if (s->rtavl_link[0] != NULL)
  r->rtavl_link[1] = s->rtavl_link[0];
else
  {
    r->rtavl_rtag = RTAVL_THREAD;
    r->rtavl_link[1] = s;
  }

   Finally, we copy p's old information into s, except for the actual
data:

437. <Case 4 in RTAVL deletion 435> +=
s->rtavl_balance = p->rtavl_balance;
s->rtavl_link[0] = p->rtavl_link[0];
s->rtavl_link[1] = p->rtavl_link[1];
s->rtavl_rtag = p->rtavl_rtag;

